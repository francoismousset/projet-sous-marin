
Carte_capteur.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  00000a54  00000ae8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a54  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000044  00800104  00800104  00000aec  2**0
                  ALLOC
  3 .debug_aranges 00000100  00000000  00000000  00000aec  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000068b  00000000  00000000  00000bec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000010b7  00000000  00000000  00001277  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000006b6  00000000  00000000  0000232e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000011ee  00000000  00000000  000029e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000330  00000000  00000000  00003bd4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000005d5  00000000  00000000  00003f04  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000574  00000000  00000000  000044d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  00004a4d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	33 c0       	rjmp	.+102    	; 0x6a <__bad_interrupt>
   4:	32 c0       	rjmp	.+100    	; 0x6a <__bad_interrupt>
   6:	31 c0       	rjmp	.+98     	; 0x6a <__bad_interrupt>
   8:	30 c0       	rjmp	.+96     	; 0x6a <__bad_interrupt>
   a:	2f c0       	rjmp	.+94     	; 0x6a <__bad_interrupt>
   c:	2e c0       	rjmp	.+92     	; 0x6a <__bad_interrupt>
   e:	2d c0       	rjmp	.+90     	; 0x6a <__bad_interrupt>
  10:	2c c0       	rjmp	.+88     	; 0x6a <__bad_interrupt>
  12:	2b c0       	rjmp	.+86     	; 0x6a <__bad_interrupt>
  14:	2a c0       	rjmp	.+84     	; 0x6a <__bad_interrupt>
  16:	41 c4       	rjmp	.+2178   	; 0x89a <__vector_11>
  18:	28 c0       	rjmp	.+80     	; 0x6a <__bad_interrupt>
  1a:	27 c0       	rjmp	.+78     	; 0x6a <__bad_interrupt>
  1c:	26 c0       	rjmp	.+76     	; 0x6a <__bad_interrupt>
  1e:	25 c0       	rjmp	.+74     	; 0x6a <__bad_interrupt>
  20:	24 c0       	rjmp	.+72     	; 0x6a <__bad_interrupt>
  22:	23 c0       	rjmp	.+70     	; 0x6a <__bad_interrupt>
  24:	c4 c2       	rjmp	.+1416   	; 0x5ae <__vector_18>
  26:	21 c0       	rjmp	.+66     	; 0x6a <__bad_interrupt>
  28:	20 c0       	rjmp	.+64     	; 0x6a <__bad_interrupt>
  2a:	1f c0       	rjmp	.+62     	; 0x6a <__bad_interrupt>
  2c:	1e c0       	rjmp	.+60     	; 0x6a <__bad_interrupt>
  2e:	1d c0       	rjmp	.+58     	; 0x6a <__bad_interrupt>
  30:	1c c0       	rjmp	.+56     	; 0x6a <__bad_interrupt>
  32:	1b c0       	rjmp	.+54     	; 0x6a <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	d4 e0       	ldi	r29, 0x04	; 4
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	cd bf       	out	0x3d, r28	; 61

00000040 <__do_copy_data>:
  40:	11 e0       	ldi	r17, 0x01	; 1
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	b1 e0       	ldi	r27, 0x01	; 1
  46:	e4 e5       	ldi	r30, 0x54	; 84
  48:	fa e0       	ldi	r31, 0x0A	; 10
  4a:	02 c0       	rjmp	.+4      	; 0x50 <.do_copy_data_start>

0000004c <.do_copy_data_loop>:
  4c:	05 90       	lpm	r0, Z+
  4e:	0d 92       	st	X+, r0

00000050 <.do_copy_data_start>:
  50:	a4 30       	cpi	r26, 0x04	; 4
  52:	b1 07       	cpc	r27, r17
  54:	d9 f7       	brne	.-10     	; 0x4c <.do_copy_data_loop>

00000056 <__do_clear_bss>:
  56:	11 e0       	ldi	r17, 0x01	; 1
  58:	a4 e0       	ldi	r26, 0x04	; 4
  5a:	b1 e0       	ldi	r27, 0x01	; 1
  5c:	01 c0       	rjmp	.+2      	; 0x60 <.do_clear_bss_start>

0000005e <.do_clear_bss_loop>:
  5e:	1d 92       	st	X+, r1

00000060 <.do_clear_bss_start>:
  60:	a8 34       	cpi	r26, 0x48	; 72
  62:	b1 07       	cpc	r27, r17
  64:	e1 f7       	brne	.-8      	; 0x5e <.do_clear_bss_loop>
  66:	d4 d2       	rcall	.+1448   	; 0x610 <main>
  68:	f3 c4       	rjmp	.+2534   	; 0xa50 <_exit>

0000006a <__bad_interrupt>:
  6a:	ca cf       	rjmp	.-108    	; 0x0 <__vectors>

0000006c <process_bcc_3964r>:
//Permet de pré-calculer le bcc avant l'envoi d'une trame
//Paramètres : - data[] => tableau à envoyer par le protocole
//			   - lenght => longueur du tableau data[]
//Valeur de retour : - le bcc pré-calculé
char process_bcc_3964r(char data[], unsigned char lenght)
{
  6c:	fc 01       	movw	r30, r24
  6e:	92 e0       	ldi	r25, 0x02	; 2
  70:	20 e0       	ldi	r18, 0x00	; 0
  72:	07 c0       	rjmp	.+14     	; 0x82 <process_bcc_3964r+0x16>
	unsigned char bcc = 0, i;

	bcc ^= STX;
	for(i=0; i<lenght; i++)
	{
		bcc ^= data[i];
  74:	80 81       	ld	r24, Z
  76:	98 27       	eor	r25, r24
		//On compte un double DLE
		if(data[i] == DLE)
  78:	80 31       	cpi	r24, 0x10	; 16
  7a:	09 f4       	brne	.+2      	; 0x7e <process_bcc_3964r+0x12>
			bcc ^= DLE;
  7c:	98 27       	eor	r25, r24
char process_bcc_3964r(char data[], unsigned char lenght)
{
	unsigned char bcc = 0, i;

	bcc ^= STX;
	for(i=0; i<lenght; i++)
  7e:	2f 5f       	subi	r18, 0xFF	; 255
  80:	31 96       	adiw	r30, 0x01	; 1
  82:	26 17       	cp	r18, r22
  84:	b8 f3       	brcs	.-18     	; 0x74 <process_bcc_3964r+0x8>
	}
	bcc ^= DLE;
	bcc ^= ETX;

	return bcc;
}
  86:	83 e1       	ldi	r24, 0x13	; 19
  88:	89 27       	eor	r24, r25
  8a:	08 95       	ret

0000008c <sum_error_3964r>:
char sum_error_3964r(void)
{
	unsigned char sum, i;

	for(i=0, sum=0; i<NB_ERRORS; i++)
		sum += tab_error_3964r[i];
  8c:	80 91 0a 01 	lds	r24, 0x010A
  90:	90 91 09 01 	lds	r25, 0x0109
  94:	89 0f       	add	r24, r25
  96:	90 91 0b 01 	lds	r25, 0x010B
  9a:	89 0f       	add	r24, r25
  9c:	90 91 0c 01 	lds	r25, 0x010C
  a0:	89 0f       	add	r24, r25
  a2:	90 91 0d 01 	lds	r25, 0x010D

	return sum;
}
  a6:	89 0f       	add	r24, r25
  a8:	08 95       	ret

000000aa <get_data_3964r>:
//Fonction get_data_3964r
//Recoi des données sur le protocole 3964 par le port série
//Paramètres : - data[] => tableau qui va recevoir les données par le protocole
//Valeur de retour : Aucune
void get_data_3964r(char data[])
{
  aa:	9f 92       	push	r9
  ac:	af 92       	push	r10
  ae:	bf 92       	push	r11
  b0:	cf 92       	push	r12
  b2:	df 92       	push	r13
  b4:	ef 92       	push	r14
  b6:	ff 92       	push	r15
  b8:	0f 93       	push	r16
  ba:	1f 93       	push	r17
  bc:	df 93       	push	r29
  be:	cf 93       	push	r28
  c0:	00 d0       	rcall	.+0      	; 0xc2 <get_data_3964r+0x18>
  c2:	0f 92       	push	r0
  c4:	cd b7       	in	r28, 0x3d	; 61
  c6:	de b7       	in	r29, 0x3e	; 62
  c8:	6c 01       	movw	r12, r24
  ca:	10 e0       	ldi	r17, 0x00	; 0
		//Désactivation de l'interruption de reception usart
		DISABLE_RX_INT_USART;	
		//Initialisation des variables
		i = 0;
		prev_c = 0;
		flag_timer1 = FALSE;
  cc:	99 24       	eor	r9, r9
  ce:	93 94       	inc	r9
		flag_error	= FALSE;
		//Initialise le tableau flag_dle avec la valeur FALSE
		memset(flag_dle,FALSE,3);
  d0:	5e 01       	movw	r10, r28
  d2:	08 94       	sec
  d4:	a1 1c       	adc	r10, r1
  d6:	b1 1c       	adc	r11, r1

	pass = 0;
	do
	{
		//Désactivation de l'interruption de reception usart
		DISABLE_RX_INT_USART;	
  d8:	80 91 c1 00 	lds	r24, 0x00C1
  dc:	8f 77       	andi	r24, 0x7F	; 127
  de:	80 93 c1 00 	sts	0x00C1, r24
		//Initialisation des variables
		i = 0;
		prev_c = 0;
		flag_timer1 = FALSE;
  e2:	90 92 0e 01 	sts	0x010E, r9
		flag_error	= FALSE;
		//Initialise le tableau flag_dle avec la valeur FALSE
		memset(flag_dle,FALSE,3);
  e6:	c5 01       	movw	r24, r10
  e8:	61 e0       	ldi	r22, 0x01	; 1
  ea:	70 e0       	ldi	r23, 0x00	; 0
  ec:	43 e0       	ldi	r20, 0x03	; 3
  ee:	50 e0       	ldi	r21, 0x00	; 0
  f0:	a8 d4       	rcall	.+2384   	; 0xa42 <memset>
	
		//On attend de recevoir un caractère
		if (pass==1)	
  f2:	11 30       	cpi	r17, 0x01	; 1
  f4:	11 f4       	brne	.+4      	; 0xfa <get_data_3964r+0x50>
		{
			c = getchar_usart();
  f6:	f8 d3       	rcall	.+2032   	; 0x8e8 <getchar_usart>
  f8:	02 c0       	rjmp	.+4      	; 0xfe <get_data_3964r+0x54>
		}
		else
		{
			c = UDR0 ;// Mettre dans le buffer l'octet reçu sur RX	
  fa:	80 91 c6 00 	lds	r24, 0x00C6
			pass=1;
		}

		//Si on reçoi un STX
		if(c == STX)
  fe:	82 30       	cpi	r24, 0x02	; 2
 100:	09 f0       	breq	.+2      	; 0x104 <get_data_3964r+0x5a>
 102:	55 c0       	rjmp	.+170    	; 0x1ae <get_data_3964r+0x104>
		{
			//Calcul du bcc
			bcc = STX;

			//On répond DLE
			putchar_usart(DLE);
 104:	80 e1       	ldi	r24, 0x10	; 16
 106:	e8 d3       	rcall	.+2000   	; 0x8d8 <putchar_usart>
 108:	ff 24       	eor	r15, r15
 10a:	10 e0       	ldi	r17, 0x00	; 0
 10c:	82 e0       	ldi	r24, 0x02	; 2
 10e:	e8 2e       	mov	r14, r24

			//Début de la boucle de réception
			do
			{
				//Démarrage du timer avec la valeur de timeout TIMEOUT_MS
				start_timer1(TIMEOUT_MS);
 110:	80 e1       	ldi	r24, 0x10	; 16
 112:	97 e2       	ldi	r25, 0x27	; 39
 114:	aa d3       	rcall	.+1876   	; 0x86a <start_timer1>
				
				//Attend de recoir un caractère
				//Passage à l'instruction suivant si le timeout est déclenché (flag_timer1 == TRUE)
				c = getchar_usart();
 116:	e8 d3       	rcall	.+2000   	; 0x8e8 <getchar_usart>
 118:	08 2f       	mov	r16, r24
				//Stop le timer1
				stop_timer1();
 11a:	b3 d3       	rcall	.+1894   	; 0x882 <stop_timer1>
				
				//Si le timeout n'a pas expiré
				if(flag_timer1 == FALSE)
 11c:	90 91 0e 01 	lds	r25, 0x010E
 120:	91 30       	cpi	r25, 0x01	; 1
 122:	41 f5       	brne	.+80     	; 0x174 <get_data_3964r+0xca>
				{
					//Calcul du bcc					
					bcc ^= c;
 124:	e0 26       	eor	r14, r16
					//Machine d'état pour le contrôle des double DLE
					//Cette machine d'état permet de différencier 
					//les doubles DLE et le DLE de terminaison des données utiles.

					//Si le caractère précédent est différent d'un DLE et que le caractère reçu est un DLE
					if((prev_c != DLE) && (c == DLE))
 126:	80 e1       	ldi	r24, 0x10	; 16
 128:	f8 16       	cp	r15, r24
 12a:	19 f0       	breq	.+6      	; 0x132 <get_data_3964r+0x88>
 12c:	00 31       	cpi	r16, 0x10	; 16
 12e:	a9 f4       	brne	.+42     	; 0x15a <get_data_3964r+0xb0>
 130:	0d c0       	rjmp	.+26     	; 0x14c <get_data_3964r+0xa2>
						flag_dle[2] = FALSE;
					}
					else
					{
						//Si on est en présence d'un double DLE
						if((prev_c == DLE) && (c == DLE))
 132:	00 31       	cpi	r16, 0x10	; 16
 134:	79 f4       	brne	.+30     	; 0x154 <get_data_3964r+0xaa>
						{
							//Vérification d'état (1er passage)
							if(flag_dle[1] == FALSE)
 136:	8a 81       	ldd	r24, Y+2	; 0x02
 138:	81 30       	cpi	r24, 0x01	; 1
 13a:	41 f4       	brne	.+16     	; 0x14c <get_data_3964r+0xa2>
							{
								//Mise à jour des états
								flag_dle[0] = FALSE;
 13c:	89 83       	std	Y+1, r24	; 0x01
								flag_dle[1] = TRUE;
 13e:	1a 82       	std	Y+2, r1	; 0x02
								flag_dle[2] = FALSE;
 140:	8b 83       	std	Y+3, r24	; 0x03
								
								//Place la valeur DLE dans le tabeau data
								data[i] = DLE;
 142:	f6 01       	movw	r30, r12
 144:	e1 0f       	add	r30, r17
 146:	f1 1d       	adc	r31, r1
 148:	f0 82       	st	Z, r15
 14a:	0e c0       	rjmp	.+28     	; 0x168 <get_data_3964r+0xbe>
							}
							//Si 3 DLE consécutifs
							else
							{
								//Mise à jour des états
								flag_dle[0] = TRUE;
 14c:	19 82       	std	Y+1, r1	; 0x01
								flag_dle[1] = FALSE;
 14e:	9a 83       	std	Y+2, r25	; 0x02
								flag_dle[2] = FALSE;
 150:	9b 83       	std	Y+3, r25	; 0x03
 152:	0b c0       	rjmp	.+22     	; 0x16a <get_data_3964r+0xc0>
						{
							//Si le caractère présent est différent de DLE mais que le précédent est un DLE
							if((prev_c == DLE) && (c != DLE))
							{
								//Mise à jour des états
								flag_dle[1] = FALSE;
 154:	9a 83       	std	Y+2, r25	; 0x02
								flag_dle[2] = TRUE;
 156:	1b 82       	std	Y+3, r1	; 0x03
 158:	03 c0       	rjmp	.+6      	; 0x160 <get_data_3964r+0xb6>
							}

							else
							{
								//Mise à jour des états
								flag_dle[0] = FALSE;
 15a:	99 83       	std	Y+1, r25	; 0x01
								flag_dle[1] = FALSE;
 15c:	9a 83       	std	Y+2, r25	; 0x02
								flag_dle[2] = FALSE;
 15e:	9b 83       	std	Y+3, r25	; 0x03
								
								//Place la valeur c dans le tabeau data
								data[i] = c;
 160:	f6 01       	movw	r30, r12
 162:	e1 0f       	add	r30, r17
 164:	f1 1d       	adc	r31, r1
 166:	00 83       	st	Z, r16
								//Incrémentation de l'indice du tableau
								i++;
 168:	1f 5f       	subi	r17, 0xFF	; 255
 16a:	f0 2e       	mov	r15, r16
					putchar_usart(NAK);
					//Sort de la boucle de reception
					break;
				}
			//On continue de recevoir des caractères tant que on a pas déterminer le DLE de terminaison
			}while(!((flag_dle[0] == TRUE) && (flag_dle[2] == TRUE)));
 16c:	89 81       	ldd	r24, Y+1	; 0x01
 16e:	88 23       	and	r24, r24
 170:	79 f6       	brne	.-98     	; 0x110 <get_data_3964r+0x66>
 172:	03 c0       	rjmp	.+6      	; 0x17a <get_data_3964r+0xd0>
				}
				//Si le timeout a expiré
				else
				{
					//Envoi du caractère NAK
					putchar_usart(NAK);
 174:	85 e1       	ldi	r24, 0x15	; 21
 176:	b0 d3       	rcall	.+1888   	; 0x8d8 <putchar_usart>
 178:	04 c0       	rjmp	.+8      	; 0x182 <get_data_3964r+0xd8>
					//Sort de la boucle de reception
					break;
 17a:	f0 2e       	mov	r15, r16
				}
			//On continue de recevoir des caractères tant que on a pas déterminer le DLE de terminaison
			}while(!((flag_dle[0] == TRUE) && (flag_dle[2] == TRUE)));
 17c:	8b 81       	ldd	r24, Y+3	; 0x03
 17e:	88 23       	and	r24, r24
 180:	39 f6       	brne	.-114    	; 0x110 <get_data_3964r+0x66>

			//Si le timeout n'a pas expiré
			if(flag_timer1 == FALSE)
 182:	80 91 0e 01 	lds	r24, 0x010E
 186:	81 30       	cpi	r24, 0x01	; 1
 188:	91 f4       	brne	.+36     	; 0x1ae <get_data_3964r+0x104>
			{
				//Si le caractère dernier après le DLE est ETX
				if(c == ETX)
 18a:	03 30       	cpi	r16, 0x03	; 3
 18c:	81 f4       	brne	.+32     	; 0x1ae <get_data_3964r+0x104>
				{
					//Démarrage du timer1 avec valeur de timeout TIMEOUT_MS
					start_timer1(TIMEOUT_MS);
 18e:	80 e1       	ldi	r24, 0x10	; 16
 190:	97 e2       	ldi	r25, 0x27	; 39
 192:	6b d3       	rcall	.+1750   	; 0x86a <start_timer1>
					//Attend de recevoir un caractère sur le port série
					c = getchar_usart();
 194:	a9 d3       	rcall	.+1874   	; 0x8e8 <getchar_usart>
 196:	18 2f       	mov	r17, r24
					//Arret du timeout
					stop_timer1();
 198:	74 d3       	rcall	.+1768   	; 0x882 <stop_timer1>
					
					//Si le timeout n'a pas expiré
					if(flag_timer1 == FALSE)
 19a:	80 91 0e 01 	lds	r24, 0x010E
 19e:	81 30       	cpi	r24, 0x01	; 1
 1a0:	31 f4       	brne	.+12     	; 0x1ae <get_data_3964r+0x104>
					{
						//Si le bcc reçu est égale au bcc calculé
						if(c == bcc)
 1a2:	1e 15       	cp	r17, r14
 1a4:	21 f4       	brne	.+8      	; 0x1ae <get_data_3964r+0x104>
							//Envoi d'un DLE
							putchar_usart(DLE);
 1a6:	80 e1       	ldi	r24, 0x10	; 16
 1a8:	97 d3       	rcall	.+1838   	; 0x8d8 <putchar_usart>
 1aa:	91 e0       	ldi	r25, 0x01	; 1
 1ac:	03 c0       	rjmp	.+6      	; 0x1b4 <get_data_3964r+0x10a>
		}
		//Si le 1er caractère de la trame n'est pas STX
		else
		{
			//Envoi un NAK
			putchar_usart(NAK);
 1ae:	85 e1       	ldi	r24, 0x15	; 21
 1b0:	93 d3       	rcall	.+1830   	; 0x8d8 <putchar_usart>
 1b2:	90 e0       	ldi	r25, 0x00	; 0
			flag_error = TRUE;
		}
	//On continue la reception tant que le flag_timer1 ou le flag_error est à TRUE
	}while((flag_timer1 == TRUE) || (flag_error == TRUE));
 1b4:	80 91 0e 01 	lds	r24, 0x010E
 1b8:	11 e0       	ldi	r17, 0x01	; 1
 1ba:	88 23       	and	r24, r24
 1bc:	09 f4       	brne	.+2      	; 0x1c0 <get_data_3964r+0x116>
 1be:	8c cf       	rjmp	.-232    	; 0xd8 <get_data_3964r+0x2e>
 1c0:	99 23       	and	r25, r25
 1c2:	09 f4       	brne	.+2      	; 0x1c6 <get_data_3964r+0x11c>
 1c4:	89 cf       	rjmp	.-238    	; 0xd8 <get_data_3964r+0x2e>

	//On réactive les interruptions sur usart
	ENABLE_RX_INT_USART;
 1c6:	80 91 c1 00 	lds	r24, 0x00C1
 1ca:	80 68       	ori	r24, 0x80	; 128
 1cc:	80 93 c1 00 	sts	0x00C1, r24
}
 1d0:	0f 90       	pop	r0
 1d2:	0f 90       	pop	r0
 1d4:	0f 90       	pop	r0
 1d6:	cf 91       	pop	r28
 1d8:	df 91       	pop	r29
 1da:	1f 91       	pop	r17
 1dc:	0f 91       	pop	r16
 1de:	ff 90       	pop	r15
 1e0:	ef 90       	pop	r14
 1e2:	df 90       	pop	r13
 1e4:	cf 90       	pop	r12
 1e6:	bf 90       	pop	r11
 1e8:	af 90       	pop	r10
 1ea:	9f 90       	pop	r9
 1ec:	08 95       	ret

000001ee <send_data_3964r>:
//			   - lenght => longueur du tableau data[]
//Valeur de retour : - TRANSMISSION_SUCCESS
//					 - TRANSMISSION_FAILED
//					 - RECEPTION_MODE
char send_data_3964r(char data[], unsigned char lenght)
{
 1ee:	cf 92       	push	r12
 1f0:	df 92       	push	r13
 1f2:	ef 92       	push	r14
 1f4:	ff 92       	push	r15
 1f6:	0f 93       	push	r16
 1f8:	1f 93       	push	r17
 1fa:	cf 93       	push	r28
 1fc:	df 93       	push	r29
 1fe:	d8 2e       	mov	r13, r24
 200:	e9 2e       	mov	r14, r25
 202:	f6 2e       	mov	r15, r22
	unsigned char bcc, i, c;
	//Initialisation du tableau tab_error_3964r
	memset(tab_error_3964r,0,5);
 204:	85 e0       	ldi	r24, 0x05	; 5
 206:	e9 e0       	ldi	r30, 0x09	; 9
 208:	f1 e0       	ldi	r31, 0x01	; 1
 20a:	df 01       	movw	r26, r30
 20c:	1d 92       	st	X+, r1
 20e:	8a 95       	dec	r24
 210:	e9 f7       	brne	.-6      	; 0x20c <send_data_3964r+0x1e>
 212:	2d 2d       	mov	r18, r13
 214:	39 2f       	mov	r19, r25
 216:	c9 01       	movw	r24, r18
 218:	fc 01       	movw	r30, r24
 21a:	20 e0       	ldi	r18, 0x00	; 0
 21c:	92 e0       	ldi	r25, 0x02	; 2
 21e:	07 c0       	rjmp	.+14     	; 0x22e <send_data_3964r+0x40>
	unsigned char bcc = 0, i;

	bcc ^= STX;
	for(i=0; i<lenght; i++)
	{
		bcc ^= data[i];
 220:	80 81       	ld	r24, Z
 222:	98 27       	eor	r25, r24
		//On compte un double DLE
		if(data[i] == DLE)
 224:	80 31       	cpi	r24, 0x10	; 16
 226:	09 f4       	brne	.+2      	; 0x22a <send_data_3964r+0x3c>
			bcc ^= DLE;
 228:	98 27       	eor	r25, r24
char process_bcc_3964r(char data[], unsigned char lenght)
{
	unsigned char bcc = 0, i;

	bcc ^= STX;
	for(i=0; i<lenght; i++)
 22a:	2f 5f       	subi	r18, 0xFF	; 255
 22c:	31 96       	adiw	r30, 0x01	; 1
 22e:	2f 15       	cp	r18, r15
 230:	b8 f3       	brcs	.-18     	; 0x220 <send_data_3964r+0x32>
		//On compte un double DLE
		if(data[i] == DLE)
			bcc ^= DLE;
	}
	bcc ^= DLE;
	bcc ^= ETX;
 232:	03 e1       	ldi	r16, 0x13	; 19
 234:	09 27       	eor	r16, r25
	bcc = process_bcc_3964r(data, lenght);

	do
	{
		//Initialisation des différents flag
		flag_timer1 = FALSE;
 236:	cc 24       	eor	r12, r12
 238:	c3 94       	inc	r12
 23a:	c0 92 0e 01 	sts	0x010E, r12
		flag_usart	= FALSE;
 23e:	c0 92 08 01 	sts	0x0108, r12

		//Envoie du caractère STX
		putchar_usart(STX);
 242:	82 e0       	ldi	r24, 0x02	; 2
 244:	49 d3       	rcall	.+1682   	; 0x8d8 <putchar_usart>

		//Démarre le timer avec la valeur de timeout TIMEOUT_MS
		start_timer1(TIMEOUT_MS);
 246:	80 e1       	ldi	r24, 0x10	; 16
 248:	97 e2       	ldi	r25, 0x27	; 39
 24a:	0f d3       	rcall	.+1566   	; 0x86a <start_timer1>
		//Attend de recevoir un caractère
		//Si on a pas reçu de caractère avant le timeout, flag_timer1 se met à TRUE et on continue l'execution du programme
		c = getchar_usart();
 24c:	4d d3       	rcall	.+1690   	; 0x8e8 <getchar_usart>
 24e:	18 2f       	mov	r17, r24
		//On arrete le timer1
		stop_timer1();
 250:	18 d3       	rcall	.+1584   	; 0x882 <stop_timer1>

		//On vérifie le timeout n'a pas été déclenché
		if(flag_timer1 == FALSE)
 252:	80 91 0e 01 	lds	r24, 0x010E
 256:	81 30       	cpi	r24, 0x01	; 1
 258:	09 f0       	breq	.+2      	; 0x25c <send_data_3964r+0x6e>
 25a:	7a c0       	rjmp	.+244    	; 0x350 <send_data_3964r+0x162>
		{
			//Si le caractère reçu est un DLE
			if(c == DLE)
 25c:	10 31       	cpi	r17, 0x10	; 16
 25e:	09 f0       	breq	.+2      	; 0x262 <send_data_3964r+0x74>
 260:	6d c0       	rjmp	.+218    	; 0x33c <send_data_3964r+0x14e>
			{
				//Activation l'interruption de l'usart en reception
				//Si un caracère est reçu durant l'envoie, flag_usart est mis à TRUE
				ENABLE_RX_INT_USART;
 262:	80 91 c1 00 	lds	r24, 0x00C1
 266:	80 68       	ori	r24, 0x80	; 128
 268:	80 93 c1 00 	sts	0x00C1, r24
 26c:	2d 2d       	mov	r18, r13
 26e:	3e 2d       	mov	r19, r14
 270:	c9 01       	movw	r24, r18
 272:	ec 01       	movw	r28, r24
 274:	10 e0       	ldi	r17, 0x00	; 0
 276:	11 c0       	rjmp	.+34     	; 0x29a <send_data_3964r+0xac>
				//On envoie le contenu du tableau data[]
				//En fonction de la longueur donnée en paramètre
				for(i=0; i<lenght; i++)
				{
					//Si on a pas reçu de caractère
					if(flag_usart == FALSE)
 278:	80 91 08 01 	lds	r24, 0x0108
 27c:	81 30       	cpi	r24, 0x01	; 1
 27e:	79 f4       	brne	.+30     	; 0x29e <send_data_3964r+0xb0>
					{
						//Envoi des caractères du tableau data[]
						putchar_usart(data[i]);
 280:	88 81       	ld	r24, Y
 282:	2a d3       	rcall	.+1620   	; 0x8d8 <putchar_usart>
						//Traitement du double DLE
						if(data[i] == DLE)
 284:	88 81       	ld	r24, Y
 286:	80 31       	cpi	r24, 0x10	; 16
 288:	31 f4       	brne	.+12     	; 0x296 <send_data_3964r+0xa8>
						{
							//Revérification du flag_usart
							if(flag_usart == FALSE)
 28a:	80 91 08 01 	lds	r24, 0x0108
 28e:	81 30       	cpi	r24, 0x01	; 1
 290:	31 f4       	brne	.+12     	; 0x29e <send_data_3964r+0xb0>
								//Envoi du 2eme DLE
								putchar_usart(DLE);
 292:	80 e1       	ldi	r24, 0x10	; 16
 294:	21 d3       	rcall	.+1602   	; 0x8d8 <putchar_usart>
				//Si un caracère est reçu durant l'envoie, flag_usart est mis à TRUE
				ENABLE_RX_INT_USART;
				
				//On envoie le contenu du tableau data[]
				//En fonction de la longueur donnée en paramètre
				for(i=0; i<lenght; i++)
 296:	1f 5f       	subi	r17, 0xFF	; 255
 298:	21 96       	adiw	r28, 0x01	; 1
 29a:	1f 15       	cp	r17, r15
 29c:	68 f3       	brcs	.-38     	; 0x278 <send_data_3964r+0x8a>
					else
						break;
				}
				
				//Vérification du flag_usart	
				if(flag_usart == FALSE)
 29e:	80 91 08 01 	lds	r24, 0x0108
 2a2:	81 30       	cpi	r24, 0x01	; 1
 2a4:	79 f5       	brne	.+94     	; 0x304 <send_data_3964r+0x116>
				{
					//Envoi du DLE pour signifier la fin des données utiles
					putchar_usart(DLE);
 2a6:	80 e1       	ldi	r24, 0x10	; 16
 2a8:	17 d3       	rcall	.+1582   	; 0x8d8 <putchar_usart>
					//Vérification du flag_usart
					if(flag_usart == FALSE)
 2aa:	80 91 08 01 	lds	r24, 0x0108
 2ae:	81 30       	cpi	r24, 0x01	; 1
 2b0:	49 f5       	brne	.+82     	; 0x304 <send_data_3964r+0x116>
					{
						//Envoi de ETX
						putchar_usart(ETX);
 2b2:	83 e0       	ldi	r24, 0x03	; 3
 2b4:	11 d3       	rcall	.+1570   	; 0x8d8 <putchar_usart>
						//Vérification du flag_usart
						if(flag_usart == FALSE)
 2b6:	80 91 08 01 	lds	r24, 0x0108
 2ba:	81 30       	cpi	r24, 0x01	; 1
 2bc:	19 f5       	brne	.+70     	; 0x304 <send_data_3964r+0x116>
						{
							//Désactivation de l'interruption de reception usart
							DISABLE_RX_INT_USART;
 2be:	80 91 c1 00 	lds	r24, 0x00C1
 2c2:	8f 77       	andi	r24, 0x7F	; 127
 2c4:	80 93 c1 00 	sts	0x00C1, r24
							
							//Envoi du bcc
							putchar_usart(bcc);
 2c8:	80 2f       	mov	r24, r16
 2ca:	06 d3       	rcall	.+1548   	; 0x8d8 <putchar_usart>

							//Vérification du flag_usart
							if(flag_usart == FALSE)
 2cc:	80 91 08 01 	lds	r24, 0x0108
 2d0:	81 30       	cpi	r24, 0x01	; 1
 2d2:	e9 f4       	brne	.+58     	; 0x30e <send_data_3964r+0x120>
							{
								//Démarrage du timer1 avec timeout de valeur TIMEOUT_MS
								start_timer1(TIMEOUT_MS);
 2d4:	80 e1       	ldi	r24, 0x10	; 16
 2d6:	97 e2       	ldi	r25, 0x27	; 39
 2d8:	c8 d2       	rcall	.+1424   	; 0x86a <start_timer1>
								//Attend la reception d'un caractère
								c = getchar_usart();
 2da:	06 d3       	rcall	.+1548   	; 0x8e8 <getchar_usart>
 2dc:	18 2f       	mov	r17, r24
								//Arrete le timer1
								stop_timer1();
 2de:	d1 d2       	rcall	.+1442   	; 0x882 <stop_timer1>

								//Vérification que le timeout n'a pas expiré
								if(flag_timer1 == FALSE)
 2e0:	80 91 0e 01 	lds	r24, 0x010E
 2e4:	81 30       	cpi	r24, 0x01	; 1
 2e6:	41 f4       	brne	.+16     	; 0x2f8 <send_data_3964r+0x10a>
								{
									//Si on a reçu un caractère différent de DLE
									if(c != DLE)
 2e8:	10 31       	cpi	r17, 0x10	; 16
 2ea:	b1 f0       	breq	.+44     	; 0x318 <send_data_3964r+0x12a>
										//Incrémentation du nombre d'erreurs
										tab_error_3964r[1]++;
 2ec:	80 91 0a 01 	lds	r24, 0x010A
 2f0:	8f 5f       	subi	r24, 0xFF	; 255
 2f2:	80 93 0a 01 	sts	0x010A, r24
 2f6:	10 c0       	rjmp	.+32     	; 0x318 <send_data_3964r+0x12a>
								}
								else
									//Incrémentation du nombre d'erreurs
									tab_error_3964r[2]++;
 2f8:	80 91 0b 01 	lds	r24, 0x010B
 2fc:	8f 5f       	subi	r24, 0xFF	; 255
 2fe:	80 93 0b 01 	sts	0x010B, r24
 302:	0a c0       	rjmp	.+20     	; 0x318 <send_data_3964r+0x12a>
					}
					//Si interruption par l'usart
					else
					{
						//Désactivation de l'interruption de reception usart
						DISABLE_RX_INT_USART;
 304:	80 91 c1 00 	lds	r24, 0x00C1
 308:	8f 77       	andi	r24, 0x7F	; 127
 30a:	80 93 c1 00 	sts	0x00C1, r24
						//Incrémentation du nombre d'erreurs
						tab_error_3964r[3]++;
 30e:	80 91 0c 01 	lds	r24, 0x010C
 312:	8f 5f       	subi	r24, 0xFF	; 255
 314:	80 93 0c 01 	sts	0x010C, r24
char sum_error_3964r(void)
{
	unsigned char sum, i;

	for(i=0, sum=0; i<NB_ERRORS; i++)
		sum += tab_error_3964r[i];
 318:	80 91 0a 01 	lds	r24, 0x010A
 31c:	90 91 09 01 	lds	r25, 0x0109
 320:	89 0f       	add	r24, r25
 322:	90 91 0b 01 	lds	r25, 0x010B
 326:	89 0f       	add	r24, r25
 328:	90 91 0c 01 	lds	r25, 0x010C
 32c:	89 0f       	add	r24, r25
		else
			//Incrémentation du nombre d'erreurs
			tab_error_3964r[4]++;

		//Si la somme des erreurs est supérieur au seuil max
		if(sum_error_3964r() == MAX_ERRORS)
 32e:	90 91 0d 01 	lds	r25, 0x010D
 332:	89 0f       	add	r24, r25
 334:	86 30       	cpi	r24, 0x06	; 6
 336:	91 f4       	brne	.+36     	; 0x35c <send_data_3964r+0x16e>
 338:	81 e0       	ldi	r24, 0x01	; 1
 33a:	1b c0       	rjmp	.+54     	; 0x372 <send_data_3964r+0x184>
			}
			//Si le 1er caractère reçu n'est pas un DLE
			else
			{
				//Si le caractère est un STX
				if(c == STX)
 33c:	12 30       	cpi	r17, 0x02	; 2
 33e:	11 f4       	brne	.+4      	; 0x344 <send_data_3964r+0x156>
 340:	82 e0       	ldi	r24, 0x02	; 2
 342:	17 c0       	rjmp	.+46     	; 0x372 <send_data_3964r+0x184>
						flag_timer1 = TRUE;
				}
				//Si le 1er caractère est différent de DLE et STX
				else
					//Incrémentation du nombre d'erreurs
					tab_error_3964r[0]++;
 344:	80 91 09 01 	lds	r24, 0x0109
 348:	8f 5f       	subi	r24, 0xFF	; 255
 34a:	80 93 09 01 	sts	0x0109, r24
 34e:	e4 cf       	rjmp	.-56     	; 0x318 <send_data_3964r+0x12a>
			}
		}
		//Si le périphérique n'a pas répondu au STX
		else
			//Incrémentation du nombre d'erreurs
			tab_error_3964r[4]++;
 350:	80 91 0d 01 	lds	r24, 0x010D
 354:	8f 5f       	subi	r24, 0xFF	; 255
 356:	80 93 0d 01 	sts	0x010D, r24
 35a:	de cf       	rjmp	.-68     	; 0x318 <send_data_3964r+0x12a>
		if(sum_error_3964r() == MAX_ERRORS)
			//retourne une erreur de transmission
			return TRANSMISSION_FAILED;

	//On boucle tant que flag_timer1 ou flag_usart est a TRUE
	}while((flag_timer1 == TRUE) || (flag_usart == TRUE));
 35c:	80 91 0e 01 	lds	r24, 0x010E
 360:	88 23       	and	r24, r24
 362:	09 f4       	brne	.+2      	; 0x366 <send_data_3964r+0x178>
 364:	6a cf       	rjmp	.-300    	; 0x23a <send_data_3964r+0x4c>
 366:	80 91 08 01 	lds	r24, 0x0108
 36a:	88 23       	and	r24, r24
 36c:	09 f4       	brne	.+2      	; 0x370 <send_data_3964r+0x182>
 36e:	65 cf       	rjmp	.-310    	; 0x23a <send_data_3964r+0x4c>
 370:	80 e0       	ldi	r24, 0x00	; 0
	
	//la transmission s'est bien déroulée
	return TRANSMISSION_SUCCESS;
}
 372:	df 91       	pop	r29
 374:	cf 91       	pop	r28
 376:	1f 91       	pop	r17
 378:	0f 91       	pop	r16
 37a:	ff 90       	pop	r15
 37c:	ef 90       	pop	r14
 37e:	df 90       	pop	r13
 380:	cf 90       	pop	r12
 382:	08 95       	ret

00000384 <init_3964r>:
unsigned char tab_error_3964r[NB_ERRORS];

//Initialise les différents composants pour la communication en 3964r
void init_3964r(void)
{
	init_usart(MYUBRR);
 384:	87 e6       	ldi	r24, 0x67	; 103
 386:	90 e0       	ldi	r25, 0x00	; 0
 388:	94 d2       	rcall	.+1320   	; 0x8b2 <init_usart>
	init_timer1();
 38a:	61 d2       	rcall	.+1218   	; 0x84e <init_timer1>

	//memset permet d'initialiser un tableau avec un valeur par default
	//On place la valeur 0 dans les 5 cellules de tab_error_3964r
	memset(tab_error_3964r,0,5);
 38c:	85 e0       	ldi	r24, 0x05	; 5
 38e:	e9 e0       	ldi	r30, 0x09	; 9
 390:	f1 e0       	ldi	r31, 0x01	; 1
 392:	df 01       	movw	r26, r30
 394:	1d 92       	st	X+, r1
 396:	8a 95       	dec	r24
 398:	e9 f7       	brne	.-6      	; 0x394 <init_3964r+0x10>
}
 39a:	08 95       	ret

0000039c <initDS1621>:

/*********************************************************************/
// FUNCTION: char initDS1631(unsigned char addr_mode)
// PURPOSE: Initialisation d'un capteur de T° dont l'adresse I2C est spécifiée
unsigned char initDS1621(unsigned char addr_mode)
{
 39c:	0f 93       	push	r16
 39e:	1f 93       	push	r17
 3a0:	18 2f       	mov	r17, r24
	unsigned char ret;

    ret = i2c_start(addr_mode+I2C_WRITE);       // Start avec adresse capteur + write bit
 3a2:	41 d0       	rcall	.+130    	; 0x426 <i2c_start>
 3a4:	08 2f       	mov	r16, r24
	/* Si le capteur n'est pas présent sur le bus I2C */
    if ( ret ) // Si le capteur n'est pas présent sur le bus I2C
 3a6:	88 23       	and	r24, r24
 3a8:	19 f0       	breq	.+6      	; 0x3b0 <initDS1621+0x14>
	{
        i2c_stop();		// Fin de communication sur le bus I2C
 3aa:	8d d0       	rcall	.+282    	; 0x4c6 <i2c_stop>
        sbiBF(PORTB,1); // Allumer LED si erreur
 3ac:	29 9a       	sbi	0x05, 1	; 5
 3ae:	12 c0       	rjmp	.+36     	; 0x3d4 <initDS1621+0x38>
    }
	/* Le capteur est présent sur le bus I2C */
	else 
	{
        i2c_write(ACCESS_CFG);  // Envoyer commande "Access Config"
 3b0:	8c ea       	ldi	r24, 0xAC	; 172
 3b2:	91 d0       	rcall	.+290    	; 0x4d6 <i2c_write>
        i2c_write(POL);  		// Envoyer commande "Output polarity active high, continuous conversion" 
 3b4:	82 e0       	ldi	r24, 0x02	; 2
 3b6:	8f d0       	rcall	.+286    	; 0x4d6 <i2c_write>
		i2c_stop();				// Fin de communication sur le bus I2C
 3b8:	86 d0       	rcall	.+268    	; 0x4c6 <i2c_stop>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 3ba:	80 e3       	ldi	r24, 0x30	; 48
 3bc:	95 e7       	ldi	r25, 0x75	; 117
 3be:	01 97       	sbiw	r24, 0x01	; 1
 3c0:	f1 f7       	brne	.-4      	; 0x3be <initDS1621+0x22>
		_delay_ms(15);			// Délais avant de communiquer à nouveau avec le capteur

		i2c_start_wait(addr_mode+I2C_WRITE);    // Start avec adresse capteur + write bit
 3c2:	81 2f       	mov	r24, r17
 3c4:	56 d0       	rcall	.+172    	; 0x472 <i2c_start_wait>
												// Et attend que le bus soit libéré
		i2c_write(START_CNV);   // Envoyer commande "Start Convert Temp"
 3c6:	8e ee       	ldi	r24, 0xEE	; 238
 3c8:	86 d0       	rcall	.+268    	; 0x4d6 <i2c_write>
		i2c_stop(); 			// Fin de communication sur le bus I2C
 3ca:	7d d0       	rcall	.+250    	; 0x4c6 <i2c_stop>
 3cc:	80 ef       	ldi	r24, 0xF0	; 240
 3ce:	95 e5       	ldi	r25, 0x55	; 85
 3d0:	01 97       	sbiw	r24, 0x01	; 1
 3d2:	f1 f7       	brne	.-4      	; 0x3d0 <initDS1621+0x34>
		_delay_ms(11);			// Délais avant de communiquer à nouveau avec le capteur
	}
	return ret;
}
 3d4:	80 2f       	mov	r24, r16
 3d6:	1f 91       	pop	r17
 3d8:	0f 91       	pop	r16
 3da:	08 95       	ret

000003dc <get_DS1621_Devices>:

/*********************************************************************/
// FUNCTION: get_DS1631_Devices(unsigned char addr_mode, char *listTemp)
// PURPOSE: Aquérir la T° d'un DS1621 dont l'adresse I2C est spécifiée
unsigned char get_DS1621_Devices(unsigned char addr_mode, char *listTemp)
{
 3dc:	0f 93       	push	r16
 3de:	1f 93       	push	r17
 3e0:	cf 93       	push	r28
 3e2:	df 93       	push	r29
 3e4:	08 2f       	mov	r16, r24
 3e6:	eb 01       	movw	r28, r22
    unsigned char ACQUISITION_STATUT;
	unsigned char ret;
	
	ret = i2c_start(addr_mode+I2C_WRITE);       // Start avec adresse capteur + write bit
 3e8:	1e d0       	rcall	.+60     	; 0x426 <i2c_start>
 3ea:	18 2f       	mov	r17, r24
	i2c_stop();
 3ec:	6c d0       	rcall	.+216    	; 0x4c6 <i2c_stop>
	
	if (!ret)
 3ee:	11 23       	and	r17, r17
 3f0:	11 f0       	breq	.+4      	; 0x3f6 <get_DS1621_Devices+0x1a>
 3f2:	81 e0       	ldi	r24, 0x01	; 1
 3f4:	0d c0       	rjmp	.+26     	; 0x410 <get_DS1621_Devices+0x34>
	{
		i2c_start_wait(addr_mode+I2C_WRITE);    	// Start avec adresse capteur + write bit
 3f6:	80 2f       	mov	r24, r16
 3f8:	3c d0       	rcall	.+120    	; 0x472 <i2c_start_wait>
													// Et attend que le bus soit libéré
	    i2c_write(RD_TEMP);  		// Envoyer commande "Read Temperature"
 3fa:	8a ea       	ldi	r24, 0xAA	; 170
 3fc:	6c d0       	rcall	.+216    	; 0x4d6 <i2c_write>
		i2c_rep_start(addr_mode+I2C_READ);        	// Repeated start avec adresse capteur + write bit
 3fe:	80 2f       	mov	r24, r16
 400:	8f 5f       	subi	r24, 0xFF	; 255
 402:	5f d0       	rcall	.+190    	; 0x4c2 <i2c_rep_start>

		listTemp[0] = i2c_readAck();	// Sauvegarder les bits de poids fort + Acknowledge
 404:	7a d0       	rcall	.+244    	; 0x4fa <i2c_readAck>
 406:	88 83       	st	Y, r24
		listTemp[1] = i2c_readNak();	// Sauvegarder les bits de poids faible + Not acknowledge
 408:	82 d0       	rcall	.+260    	; 0x50e <i2c_readNak>
 40a:	89 83       	std	Y+1, r24	; 0x01

	    i2c_stop();							// Fin de communication sur le bus I2C
 40c:	5c d0       	rcall	.+184    	; 0x4c6 <i2c_stop>
 40e:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		ACQUISITION_STATUT = FALSE ;		// Indique que l'acquisition des données est un échec
	}
	return ACQUISITION_STATUT ; 
}
 410:	df 91       	pop	r29
 412:	cf 91       	pop	r28
 414:	1f 91       	pop	r17
 416:	0f 91       	pop	r16
 418:	08 95       	ret

0000041a <i2c_init>:
*************************************************************************/
void i2c_init(void)
{
  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
  
  TWSR = 0;                         /* no prescaler */
 41a:	10 92 b9 00 	sts	0x00B9, r1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
 41e:	80 e2       	ldi	r24, 0x20	; 32
 420:	80 93 b8 00 	sts	0x00B8, r24

}/* i2c_init */
 424:	08 95       	ret

00000426 <i2c_start>:
  Issues a start condition and sends address and transfer direction.
  (7 bits for address and 1 bit for read/write)
  return 0 = device accessible, 1= failed to access device
*************************************************************************/
unsigned char i2c_start(unsigned char address)
{
 426:	98 2f       	mov	r25, r24
    uint8_t   twst;

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 428:	84 ea       	ldi	r24, 0xA4	; 164
 42a:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 42e:	80 91 bc 00 	lds	r24, 0x00BC
 432:	87 ff       	sbrs	r24, 7
 434:	fc cf       	rjmp	.-8      	; 0x42e <i2c_start+0x8>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
 436:	80 91 b9 00 	lds	r24, 0x00B9
 43a:	88 7f       	andi	r24, 0xF8	; 248
	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
 43c:	88 30       	cpi	r24, 0x08	; 8
 43e:	21 f0       	breq	.+8      	; 0x448 <i2c_start+0x22>
 440:	80 31       	cpi	r24, 0x10	; 16
 442:	11 f0       	breq	.+4      	; 0x448 <i2c_start+0x22>
 444:	81 e0       	ldi	r24, 0x01	; 1
 446:	08 95       	ret

	// send device address (load address, and start transmission of address)
	TWDR = address; 
 448:	90 93 bb 00 	sts	0x00BB, r25
	TWCR = (1<<TWINT) | (1<<TWEN);
 44c:	84 e8       	ldi	r24, 0x84	; 132
 44e:	80 93 bc 00 	sts	0x00BC, r24

	// wail until transmission completed (when TWINT is set) and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));
 452:	80 91 bc 00 	lds	r24, 0x00BC
 456:	87 ff       	sbrs	r24, 7
 458:	fc cf       	rjmp	.-8      	; 0x452 <i2c_start+0x2c>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
 45a:	90 91 b9 00 	lds	r25, 0x00B9
 45e:	98 7f       	andi	r25, 0xF8	; 248
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 460:	98 31       	cpi	r25, 0x18	; 24
 462:	11 f4       	brne	.+4      	; 0x468 <i2c_start+0x42>
 464:	80 e0       	ldi	r24, 0x00	; 0
 466:	08 95       	ret
 468:	80 e0       	ldi	r24, 0x00	; 0
 46a:	90 34       	cpi	r25, 0x40	; 64
 46c:	09 f0       	breq	.+2      	; 0x470 <i2c_start+0x4a>
 46e:	81 e0       	ldi	r24, 0x01	; 1

	return 0;

}/* i2c_start */
 470:	08 95       	ret

00000472 <i2c_start_wait>:
 If device is busy, use ack polling to wait until device is ready
 
 Input:   address and transfer direction of I2C device
*************************************************************************/
void i2c_start_wait(unsigned char address)
{
 472:	98 2f       	mov	r25, r24


    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 474:	44 ea       	ldi	r20, 0xA4	; 164
    	twst = TW_STATUS & 0xF8;
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
    
    	// send device address
    	TWDR = address;
    	TWCR = (1<<TWINT) | (1<<TWEN);
 476:	34 e8       	ldi	r19, 0x84	; 132
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
    	{    	    
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 478:	24 e9       	ldi	r18, 0x94	; 148


    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 47a:	40 93 bc 00 	sts	0x00BC, r20
    
    	// wait until transmission completed
    	while(!(TWCR & (1<<TWINT)));
 47e:	80 91 bc 00 	lds	r24, 0x00BC
 482:	87 ff       	sbrs	r24, 7
 484:	fc cf       	rjmp	.-8      	; 0x47e <i2c_start_wait+0xc>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
 486:	80 91 b9 00 	lds	r24, 0x00B9
 48a:	88 7f       	andi	r24, 0xF8	; 248
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
 48c:	88 30       	cpi	r24, 0x08	; 8
 48e:	11 f0       	breq	.+4      	; 0x494 <i2c_start_wait+0x22>
 490:	80 31       	cpi	r24, 0x10	; 16
 492:	99 f7       	brne	.-26     	; 0x47a <i2c_start_wait+0x8>
    
    	// send device address
    	TWDR = address;
 494:	90 93 bb 00 	sts	0x00BB, r25
    	TWCR = (1<<TWINT) | (1<<TWEN);
 498:	30 93 bc 00 	sts	0x00BC, r19
    
    	// wail until transmission completed
    	while(!(TWCR & (1<<TWINT)));
 49c:	80 91 bc 00 	lds	r24, 0x00BC
 4a0:	87 ff       	sbrs	r24, 7
 4a2:	fc cf       	rjmp	.-8      	; 0x49c <i2c_start_wait+0x2a>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
 4a4:	80 91 b9 00 	lds	r24, 0x00B9
 4a8:	88 7f       	andi	r24, 0xF8	; 248
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
 4aa:	80 32       	cpi	r24, 0x20	; 32
 4ac:	11 f0       	breq	.+4      	; 0x4b2 <i2c_start_wait+0x40>
 4ae:	88 35       	cpi	r24, 0x58	; 88
 4b0:	39 f4       	brne	.+14     	; 0x4c0 <i2c_start_wait+0x4e>
    	{    	    
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 4b2:	20 93 bc 00 	sts	0x00BC, r18
	        
	        // wait until stop condition is executed and bus released
	        while(TWCR & (1<<TWSTO));
 4b6:	80 91 bc 00 	lds	r24, 0x00BC
 4ba:	84 fd       	sbrc	r24, 4
 4bc:	fc cf       	rjmp	.-8      	; 0x4b6 <i2c_start_wait+0x44>
 4be:	dd cf       	rjmp	.-70     	; 0x47a <i2c_start_wait+0x8>
 4c0:	08 95       	ret

000004c2 <i2c_rep_start>:
 Return:  0 device accessible
          1 failed to access device
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
    return i2c_start( address );
 4c2:	b1 df       	rcall	.-158    	; 0x426 <i2c_start>

}/* i2c_rep_start */
 4c4:	08 95       	ret

000004c6 <i2c_stop>:
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
    /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 4c6:	84 e9       	ldi	r24, 0x94	; 148
 4c8:	80 93 bc 00 	sts	0x00BC, r24
	
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));
 4cc:	80 91 bc 00 	lds	r24, 0x00BC
 4d0:	84 fd       	sbrc	r24, 4
 4d2:	fc cf       	rjmp	.-8      	; 0x4cc <i2c_stop+0x6>

}/* i2c_stop */
 4d4:	08 95       	ret

000004d6 <i2c_write>:
unsigned char i2c_write( unsigned char data )
{	
    uint8_t   twst;
    
	// send data to the previously addressed device
	TWDR = data;
 4d6:	80 93 bb 00 	sts	0x00BB, r24
	TWCR = (1<<TWINT) | (1<<TWEN);
 4da:	84 e8       	ldi	r24, 0x84	; 132
 4dc:	80 93 bc 00 	sts	0x00BC, r24

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
 4e0:	80 91 bc 00 	lds	r24, 0x00BC
 4e4:	87 ff       	sbrs	r24, 7
 4e6:	fc cf       	rjmp	.-8      	; 0x4e0 <i2c_write+0xa>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
 4e8:	80 91 b9 00 	lds	r24, 0x00B9
 4ec:	90 e0       	ldi	r25, 0x00	; 0
 4ee:	88 7f       	andi	r24, 0xF8	; 248
 4f0:	88 32       	cpi	r24, 0x28	; 40
 4f2:	09 f0       	breq	.+2      	; 0x4f6 <i2c_write+0x20>
 4f4:	91 e0       	ldi	r25, 0x01	; 1
	if( twst != TW_MT_DATA_ACK) return 1;
	return 0;

}/* i2c_write */
 4f6:	89 2f       	mov	r24, r25
 4f8:	08 95       	ret

000004fa <i2c_readAck>:
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readAck(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 4fa:	84 ec       	ldi	r24, 0xC4	; 196
 4fc:	80 93 bc 00 	sts	0x00BC, r24
	while(!(TWCR & (1<<TWINT)));    
 500:	80 91 bc 00 	lds	r24, 0x00BC
 504:	87 ff       	sbrs	r24, 7
 506:	fc cf       	rjmp	.-8      	; 0x500 <__stack+0x1>

    return TWDR;
 508:	80 91 bb 00 	lds	r24, 0x00BB

}/* i2c_readAck */
 50c:	08 95       	ret

0000050e <i2c_readNak>:
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readNak(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN);
 50e:	84 e8       	ldi	r24, 0x84	; 132
 510:	80 93 bc 00 	sts	0x00BC, r24
	while(!(TWCR & (1<<TWINT)));
 514:	80 91 bc 00 	lds	r24, 0x00BC
 518:	87 ff       	sbrs	r24, 7
 51a:	fc cf       	rjmp	.-8      	; 0x514 <i2c_readNak+0x6>
	
    return TWDR;
 51c:	80 91 bb 00 	lds	r24, 0x00BB

}/* i2c_readNak */
 520:	08 95       	ret

00000522 <transmission>:


/***** Transmission vers FoxBoard *****/
void transmission(char commande, char data_low, char data_high)
{
	if ((data_low!=0xFF)&(data_high!=0xFF)) 						// Si FF pour les deux data, alors le capteur n'est pas connecter
 522:	6f 3f       	cpi	r22, 0xFF	; 255
 524:	49 f0       	breq	.+18     	; 0x538 <transmission+0x16>
 526:	4f 3f       	cpi	r20, 0xFF	; 255
 528:	39 f0       	breq	.+14     	; 0x538 <transmission+0x16>
	{
		data_to_transmit[0]=commande;
 52a:	80 93 18 01 	sts	0x0118, r24
		data_to_transmit[1]=data_low;								// Charge le byte de poid faible dans le premier byte			
 52e:	60 93 19 01 	sts	0x0119, r22
		data_to_transmit[2]=data_high;								// Charge le byte de poid fort dans le deuxième byte
 532:	40 93 1a 01 	sts	0x011A, r20
 536:	06 c0       	rjmp	.+12     	; 0x544 <transmission+0x22>
	}
	else															// si le capteur n'est pas connecter, alors on envoie deux octets
	{																//		avec tous les bits à 0
		data_to_transmit[0] = 0 ;
 538:	10 92 18 01 	sts	0x0118, r1
		data_to_transmit[1] = 0 ;
 53c:	10 92 19 01 	sts	0x0119, r1
		data_to_transmit[2] = 0 ;
 540:	10 92 1a 01 	sts	0x011A, r1
	}
	DISABLE_RX_INT_USART;
 544:	80 91 c1 00 	lds	r24, 0x00C1
 548:	8f 77       	andi	r24, 0x7F	; 127
 54a:	80 93 c1 00 	sts	0x00C1, r24
	fonctionnement_RX = 0 ; 									// Indique que l'on va se mettre en mode d'envoi de donné vers la Fox
 54e:	10 92 2b 01 	sts	0x012B, r1
	TRANSMIT_STATUT = send_data_3964r(data_to_transmit,3);			// Envoie les deux bytes en protocole 3964	
 552:	88 e1       	ldi	r24, 0x18	; 24
 554:	91 e0       	ldi	r25, 0x01	; 1
 556:	63 e0       	ldi	r22, 0x03	; 3
 558:	4a de       	rcall	.-876    	; 0x1ee <send_data_3964r>
 55a:	80 93 1e 01 	sts	0x011E, r24
	fonctionnement_RX = 1 ;									// Indique que l'on se remet en mode de réception de donnée venant de la Fox
 55e:	81 e0       	ldi	r24, 0x01	; 1
 560:	80 93 2b 01 	sts	0x012B, r24
	
	ENABLE_RX_INT_USART;
 564:	80 91 c1 00 	lds	r24, 0x00C1
 568:	80 68       	ori	r24, 0x80	; 128
 56a:	80 93 c1 00 	sts	0x00C1, r24
}
 56e:	08 95       	ret

00000570 <init>:

/***** Initialisation *****/
void init()							
{
	unsigned char i ;
	cli();							// Désactiver toutes les interruptions
 570:	f8 94       	cli
    
	sDDR(DDRB,0); 					// PORTB.0 en sortie
 572:	20 9a       	sbi	0x04, 0	; 4
	sDDR(DDRB,1); 					// PORTB.1 en sortie
 574:	21 9a       	sbi	0x04, 1	; 4
	sDDR(DDRD,2);
 576:	52 9a       	sbi	0x0a, 2	; 10
	sDDR(DDRD,3);
 578:	53 9a       	sbi	0x0a, 3	; 10
	sDDR(DDRD,4);
 57a:	54 9a       	sbi	0x0a, 4	; 10
	cbiBF(PORTB,0);					// Mettre à zéro le portB.0
 57c:	28 98       	cbi	0x05, 0	; 5

	sDDR(DDRD,1);					// mettre port TX en sortie
 57e:	51 9a       	sbi	0x0a, 1	; 10
	sbiBF(PORTD,0); 				// mettre pull-up sur RX
 580:	58 9a       	sbi	0x0b, 0	; 11

	for(i=0;i<=4;i++)				// Initialiser les demandes à 0 qui signifie qu'il n'y a pas de demande de la part de la FoxBoard
	{
		data[i]=0x00;
 582:	10 92 33 01 	sts	0x0133, r1
 586:	10 92 34 01 	sts	0x0134, r1
 58a:	10 92 35 01 	sts	0x0135, r1
 58e:	10 92 36 01 	sts	0x0136, r1
 592:	10 92 37 01 	sts	0x0137, r1
	}

    i2c_init();              		// Initialisation interface I2C
 596:	41 df       	rcall	.-382    	; 0x41a <i2c_init>

	init_3964r();					// Initialisation de la communication en protocole 3964 avec la FoxBoard
 598:	f5 de       	rcall	.-534    	; 0x384 <init_3964r>
	ENABLE_RX_INT_USART;			// Autoriser les interruption série RX
 59a:	e1 ec       	ldi	r30, 0xC1	; 193
 59c:	f0 e0       	ldi	r31, 0x00	; 0
 59e:	80 81       	ld	r24, Z
 5a0:	80 68       	ori	r24, 0x80	; 128
 5a2:	80 83       	st	Z, r24
	fonctionnement_RX = 1;			// mode de réception
 5a4:	81 e0       	ldi	r24, 0x01	; 1
 5a6:	80 93 2b 01 	sts	0x012B, r24
	//TIMER0_20ms_Init();				// Initialise timer 0
	//TIMER2_20ms_Init();				// Initialise timer 2
	//PCINT0_ON();					// Active les interruptions sur INT0
	//PCINT1_ON();					// Active les interruptions sur INT1

	sei();							// Activer toutes les interruptions	
 5aa:	78 94       	sei
}
 5ac:	08 95       	ret

000005ae <__vector_18>:
/*************************/

/***** Interruption usart en reception *****/

ISR(USART_RX_vect)
{
 5ae:	1f 92       	push	r1
 5b0:	0f 92       	push	r0
 5b2:	0f b6       	in	r0, 0x3f	; 63
 5b4:	0f 92       	push	r0
 5b6:	11 24       	eor	r1, r1
 5b8:	2f 93       	push	r18
 5ba:	3f 93       	push	r19
 5bc:	4f 93       	push	r20
 5be:	5f 93       	push	r21
 5c0:	6f 93       	push	r22
 5c2:	7f 93       	push	r23
 5c4:	8f 93       	push	r24
 5c6:	9f 93       	push	r25
 5c8:	af 93       	push	r26
 5ca:	bf 93       	push	r27
 5cc:	ef 93       	push	r30
 5ce:	ff 93       	push	r31
	if(fonctionnement_RX==0) // mode d'envoi
 5d0:	80 91 2b 01 	lds	r24, 0x012B
 5d4:	88 23       	and	r24, r24
 5d6:	19 f4       	brne	.+6      	; 0x5de <__vector_18+0x30>
	{
		//Si un caractère est reçu, on set le flag_usart à TRUE pour quitter la boucle de getchar_usart
		flag_usart = TRUE;
 5d8:	10 92 08 01 	sts	0x0108, r1
 5dc:	08 c0       	rjmp	.+16     	; 0x5ee <__vector_18+0x40>
	}
	else if (fonctionnement_RX==1) // mode de réception
 5de:	81 30       	cpi	r24, 0x01	; 1
 5e0:	31 f4       	brne	.+12     	; 0x5ee <__vector_18+0x40>
	{
		get_data_3964r(data);
 5e2:	83 e3       	ldi	r24, 0x33	; 51
 5e4:	91 e0       	ldi	r25, 0x01	; 1
 5e6:	61 dd       	rcall	.-1342   	; 0xaa <get_data_3964r>
		sbiBF(PORTB,1);	
 5e8:	29 9a       	sbi	0x05, 1	; 5
		data[4]=0x00; // Force le dernier bit des demandes à 0.  Au maximum 4 demandes qui n'ont pas été traitée peuvent être enregistrée.		
 5ea:	10 92 37 01 	sts	0x0137, r1
	}
}
 5ee:	ff 91       	pop	r31
 5f0:	ef 91       	pop	r30
 5f2:	bf 91       	pop	r27
 5f4:	af 91       	pop	r26
 5f6:	9f 91       	pop	r25
 5f8:	8f 91       	pop	r24
 5fa:	7f 91       	pop	r23
 5fc:	6f 91       	pop	r22
 5fe:	5f 91       	pop	r21
 600:	4f 91       	pop	r20
 602:	3f 91       	pop	r19
 604:	2f 91       	pop	r18
 606:	0f 90       	pop	r0
 608:	0f be       	out	0x3f, r0	; 63
 60a:	0f 90       	pop	r0
 60c:	1f 90       	pop	r1
 60e:	18 95       	reti

00000610 <main>:
/*****************************************************************/
/*********************** Programme principal *********************/
/*****************************************************************/

int main(void)
{
 610:	0f 93       	push	r16
 612:	1f 93       	push	r17
 614:	cf 93       	push	r28
 616:	df 93       	push	r29
	/***** Variables locales *****/
	
	init();									// Initialisations globales
 618:	ab df       	rcall	.-170    	; 0x570 <init>
	
	dev1_access = initDS1621(ADD1_DS1621);	// Initialiser le capteur de T° n°1
 61a:	80 e9       	ldi	r24, 0x90	; 144
 61c:	bf de       	rcall	.-642    	; 0x39c <initDS1621>
 61e:	80 93 1a 01 	sts	0x011A, r24
	dev2_access = initDS1621(ADD2_DS1621);	// Initialiser le capteur de T° n°1
 622:	82 e9       	ldi	r24, 0x92	; 146
 624:	bb de       	rcall	.-650    	; 0x39c <initDS1621>
 626:	80 93 41 01 	sts	0x0141, r24
	dev3_access = initDS1621(ADD3_DS1621);	// Initialiser le capteur de T° n°1
 62a:	84 e9       	ldi	r24, 0x94	; 148
 62c:	b7 de       	rcall	.-658    	; 0x39c <initDS1621>
 62e:	80 93 2c 01 	sts	0x012C, r24
 632:	c8 ec       	ldi	r28, 0xC8	; 200
 634:	d0 e0       	ldi	r29, 0x00	; 0
					TEMP3H = listTemp[0];
					TEMP3L = listTemp[1];
				}
				else 
				{
					TEMP1H = 0xFF ;
 636:	1f ef       	ldi	r17, 0xFF	; 255
				Sens_0 = 0 ;
				transmission(CMD_SENS_0_NEGATIF,Conf_sens0n, 0x00 );
			}
			else if (data[0]==CMD_SENS_1_POSITIF)
			{
				Sens_1 = 1 ;
 638:	01 e0       	ldi	r16, 0x01	; 1
	

	/* boucle infinie */
	for(;;)
	{	
		if (data[0] == 0x00 )
 63a:	80 91 33 01 	lds	r24, 0x0133
 63e:	88 23       	and	r24, r24
 640:	09 f0       	breq	.+2      	; 0x644 <main+0x34>
 642:	51 c0       	rjmp	.+162    	; 0x6e6 <main+0xd6>
 644:	8c ed       	ldi	r24, 0xDC	; 220
 646:	95 e0       	ldi	r25, 0x05	; 5
 648:	fe 01       	movw	r30, r28
 64a:	31 97       	sbiw	r30, 0x01	; 1
 64c:	f1 f7       	brne	.-4      	; 0x64a <main+0x3a>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 64e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 650:	d9 f7       	brne	.-10     	; 0x648 <main+0x38>
		{
			_delay_ms(150);
		// Demande des informations aux capteurs
			// CAPTEUR I2C
			/* Si le capteur de T° n°1 est connecté au bus I2C */
			if(numero_capteur==0)
 652:	80 91 3a 01 	lds	r24, 0x013A
 656:	88 23       	and	r24, r24
 658:	89 f4       	brne	.+34     	; 0x67c <main+0x6c>
			{
				statut_acquisition = get_DS1621_Devices(ADD1_DS1621, listTemp); // Récupérer T° capteur n°1
 65a:	80 e9       	ldi	r24, 0x90	; 144
 65c:	6f e0       	ldi	r22, 0x0F	; 15
 65e:	71 e0       	ldi	r23, 0x01	; 1
 660:	bd de       	rcall	.-646    	; 0x3dc <get_DS1621_Devices>
 662:	80 93 21 01 	sts	0x0121, r24
				if (statut_acquisition == TRUE)
 666:	88 23       	and	r24, r24
 668:	79 f5       	brne	.+94     	; 0x6c8 <main+0xb8>
				{
					TEMP1H = listTemp[0];
 66a:	80 91 0f 01 	lds	r24, 0x010F
 66e:	80 93 15 01 	sts	0x0115, r24
					TEMP1L = listTemp[1];
 672:	80 91 10 01 	lds	r24, 0x0110
 676:	80 93 44 01 	sts	0x0144, r24
 67a:	2a c0       	rjmp	.+84     	; 0x6d0 <main+0xc0>
					TEMP1H = 0xFF ;
					TEMP1L = 0xFF ;
				}
			}
			/* Si le capteur de T° n°2 est connecté au bus I2C */
			else if(numero_capteur==1)
 67c:	81 30       	cpi	r24, 0x01	; 1
 67e:	89 f4       	brne	.+34     	; 0x6a2 <main+0x92>
			{
				statut_acquisition = get_DS1621_Devices(ADD2_DS1621, listTemp); // Récupérer T° capteur n°2
 680:	82 e9       	ldi	r24, 0x92	; 146
 682:	6f e0       	ldi	r22, 0x0F	; 15
 684:	71 e0       	ldi	r23, 0x01	; 1
 686:	aa de       	rcall	.-684    	; 0x3dc <get_DS1621_Devices>
 688:	80 93 21 01 	sts	0x0121, r24
				if (statut_acquisition == TRUE)
 68c:	88 23       	and	r24, r24
 68e:	e1 f4       	brne	.+56     	; 0x6c8 <main+0xb8>
				{
					TEMP2H = listTemp[0];
 690:	80 91 0f 01 	lds	r24, 0x010F
 694:	80 93 22 01 	sts	0x0122, r24
					TEMP2L = listTemp[1];
 698:	80 91 10 01 	lds	r24, 0x0110
 69c:	80 93 45 01 	sts	0x0145, r24
 6a0:	17 c0       	rjmp	.+46     	; 0x6d0 <main+0xc0>
					TEMP1H = 0xFF ;
					TEMP1L = 0xFF ;
				}
			}
			/* Si le capteur de T° n°3 est connecté au bus I2C */
			else if(numero_capteur==2)
 6a2:	82 30       	cpi	r24, 0x02	; 2
 6a4:	a9 f4       	brne	.+42     	; 0x6d0 <main+0xc0>
			{
				statut_acquisition = get_DS1621_Devices(ADD3_DS1621, listTemp); // Récupérer T° capteur n°3
 6a6:	84 e9       	ldi	r24, 0x94	; 148
 6a8:	6f e0       	ldi	r22, 0x0F	; 15
 6aa:	71 e0       	ldi	r23, 0x01	; 1
 6ac:	97 de       	rcall	.-722    	; 0x3dc <get_DS1621_Devices>
 6ae:	80 93 21 01 	sts	0x0121, r24
				if (statut_acquisition == TRUE)
 6b2:	88 23       	and	r24, r24
 6b4:	49 f4       	brne	.+18     	; 0x6c8 <main+0xb8>
				{
					TEMP3H = listTemp[0];
 6b6:	80 91 0f 01 	lds	r24, 0x010F
 6ba:	80 93 43 01 	sts	0x0143, r24
					TEMP3L = listTemp[1];
 6be:	80 91 10 01 	lds	r24, 0x0110
 6c2:	80 93 46 01 	sts	0x0146, r24
 6c6:	04 c0       	rjmp	.+8      	; 0x6d0 <main+0xc0>
				}
				else 
				{
					TEMP1H = 0xFF ;
 6c8:	10 93 15 01 	sts	0x0115, r17
					TEMP1L = 0xFF ;
 6cc:	10 93 44 01 	sts	0x0144, r17
				ADC_Choice = 0 ;
				ADCSRA |= (1<<ADIE);	// Active l'interruption ADC
			}*/

			// INCREMENTATION DU NUMERO DE CAPTEUR
			numero_capteur = numero_capteur+1 ;
 6d0:	80 91 3a 01 	lds	r24, 0x013A
 6d4:	8f 5f       	subi	r24, 0xFF	; 255
 6d6:	80 93 3a 01 	sts	0x013A, r24
			if(numero_capteur == nbre_max_capteur)
 6da:	83 30       	cpi	r24, 0x03	; 3
 6dc:	09 f0       	breq	.+2      	; 0x6e0 <main+0xd0>
 6de:	ad cf       	rjmp	.-166    	; 0x63a <main+0x2a>
			{
				numero_capteur = 0;
 6e0:	10 92 3a 01 	sts	0x013A, r1
 6e4:	aa cf       	rjmp	.-172    	; 0x63a <main+0x2a>
			}
		}
		else
		{
		// Envoie des informations à la foxboard
			if(data[0]==CMD_INCLINAISON) // Envoie les informations d'inclinaisons du sous-marin
 6e6:	80 36       	cpi	r24, 0x60	; 96
 6e8:	29 f4       	brne	.+10     	; 0x6f4 <main+0xe4>
			{
				transmission(CMD_INCLINAISON, ACCL, ACCH);
 6ea:	60 91 29 01 	lds	r22, 0x0129
 6ee:	40 91 2d 01 	lds	r20, 0x012D
 6f2:	9c c0       	rjmp	.+312    	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_HYGROMETRE1) // Envoie les informations d'humidité du premier capteur hygrométrique
 6f4:	80 37       	cpi	r24, 0x70	; 112
 6f6:	29 f4       	brne	.+10     	; 0x702 <main+0xf2>
			{
				transmission(CMD_HYGROMETRE1, HUM1L, HUM1H);
 6f8:	60 91 1b 01 	lds	r22, 0x011B
 6fc:	40 91 3f 01 	lds	r20, 0x013F
 700:	95 c0       	rjmp	.+298    	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_HYGROMETRE2) // Envoie les informations d'humidité du deuxième capteur hygrométrique
 702:	81 37       	cpi	r24, 0x71	; 113
 704:	29 f4       	brne	.+10     	; 0x710 <main+0x100>
			{
				transmission(CMD_HYGROMETRE2, HUM2L, HUM2H);
 706:	60 91 1d 01 	lds	r22, 0x011D
 70a:	40 91 47 01 	lds	r20, 0x0147
 70e:	8e c0       	rjmp	.+284    	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_BALLAST) // Envoie les informations de la position du ballast
 710:	80 38       	cpi	r24, 0x80	; 128
 712:	39 f4       	brne	.+14     	; 0x722 <main+0x112>
			{
				IMP1L = nbpulse_1 ;
 714:	60 91 06 01 	lds	r22, 0x0106
 718:	60 93 3c 01 	sts	0x013C, r22
				IMP1H = 0x00 ;
 71c:	10 92 17 01 	sts	0x0117, r1
 720:	84 c0       	rjmp	.+264    	; 0x82a <main+0x21a>
				transmission(CMD_BALLAST, IMP1L, IMP1H);
			}
			else if (data[0]==CMD_SYSTEME_BALLAST) // Envoie les informations de la position du chariot portant le ballast
 722:	81 38       	cpi	r24, 0x81	; 129
 724:	61 f4       	brne	.+24     	; 0x73e <main+0x12e>
			{
				IMP1L = nbpulse_2 ;
 726:	80 91 07 01 	lds	r24, 0x0107
 72a:	80 93 3c 01 	sts	0x013C, r24
				IMP1H = 0x00 ;
 72e:	10 92 17 01 	sts	0x0117, r1
				transmission(CMD_SYSTEME_BALLAST, IMP2L, IMP2H);
 732:	81 e8       	ldi	r24, 0x81	; 129
 734:	60 91 25 01 	lds	r22, 0x0125
 738:	40 91 3b 01 	lds	r20, 0x013B
 73c:	77 c0       	rjmp	.+238    	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_TEMP1) // Envoie les informations de température du premier capteur
 73e:	80 34       	cpi	r24, 0x40	; 64
 740:	41 f4       	brne	.+16     	; 0x752 <main+0x142>
			{
				transmission(CMD_TEMP1, TEMP1L, TEMP1H);
 742:	60 91 44 01 	lds	r22, 0x0144
 746:	40 91 15 01 	lds	r20, 0x0115
 74a:	eb de       	rcall	.-554    	; 0x522 <transmission>
				sbiBF(PORTD,2);
 74c:	5a 9a       	sbi	0x0b, 2	; 11
				cbiBF(PORTD,3);
 74e:	5b 98       	cbi	0x0b, 3	; 11
 750:	09 c0       	rjmp	.+18     	; 0x764 <main+0x154>
				cbiBF(PORTD,4);
			}
			else if (data[0]==CMD_TEMP2) // Envoie les informations de température du deuxième capteur
 752:	81 34       	cpi	r24, 0x41	; 65
 754:	49 f4       	brne	.+18     	; 0x768 <main+0x158>
			{
				transmission(CMD_TEMP2, TEMP2L, TEMP2H);
 756:	60 91 45 01 	lds	r22, 0x0145
 75a:	40 91 22 01 	lds	r20, 0x0122
 75e:	e1 de       	rcall	.-574    	; 0x522 <transmission>
				cbiBF(PORTD,2);
 760:	5a 98       	cbi	0x0b, 2	; 11
				sbiBF(PORTD,3);
 762:	5b 9a       	sbi	0x0b, 3	; 11
				cbiBF(PORTD,4);
 764:	5c 98       	cbi	0x0b, 4	; 11
 766:	63 c0       	rjmp	.+198    	; 0x82e <main+0x21e>
			}
			else if (data[0]==CMD_TEMP3) // Envoie les informations de température du troisième capteur
 768:	82 34       	cpi	r24, 0x42	; 66
 76a:	49 f4       	brne	.+18     	; 0x77e <main+0x16e>
			{
				transmission(CMD_TEMP3, TEMP3L, TEMP3H);
 76c:	60 91 46 01 	lds	r22, 0x0146
 770:	40 91 43 01 	lds	r20, 0x0143
 774:	d6 de       	rcall	.-596    	; 0x522 <transmission>
				cbiBF(PORTD,2);
 776:	5a 98       	cbi	0x0b, 2	; 11
				cbiBF(PORTD,3);
 778:	5b 98       	cbi	0x0b, 3	; 11
				sbiBF(PORTD, 4);
 77a:	5c 9a       	sbi	0x0b, 4	; 11
 77c:	58 c0       	rjmp	.+176    	; 0x82e <main+0x21e>
			}
			else if (data[0]==CMD_TEMP4) // Envoie les informations de température du quatrième capteur
 77e:	83 34       	cpi	r24, 0x43	; 67
 780:	29 f4       	brne	.+10     	; 0x78c <main+0x17c>
			{
				transmission(CMD_TEMP4,TEMP4L, TEMP4H);
 782:	60 91 3e 01 	lds	r22, 0x013E
 786:	40 91 40 01 	lds	r20, 0x0140
 78a:	50 c0       	rjmp	.+160    	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_TEMP5) // Envoie les informations de température du cinquième capteur
 78c:	84 34       	cpi	r24, 0x44	; 68
 78e:	29 f4       	brne	.+10     	; 0x79a <main+0x18a>
			{
				transmission(CMD_TEMP5, TEMP5L, TEMP5H);
 790:	60 91 38 01 	lds	r22, 0x0138
 794:	40 91 24 01 	lds	r20, 0x0124
 798:	49 c0       	rjmp	.+146    	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_TEMP6) // Envoie les informations de température du sixième capteur
 79a:	85 34       	cpi	r24, 0x45	; 69
 79c:	29 f4       	brne	.+10     	; 0x7a8 <main+0x198>
			{
				transmission(CMD_TEMP6, TEMP6L, TEMP6H);
 79e:	60 91 31 01 	lds	r22, 0x0131
 7a2:	40 91 1c 01 	lds	r20, 0x011C
 7a6:	42 c0       	rjmp	.+132    	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_TEMP7) // Envoie les informations de température du septième capteur
 7a8:	86 34       	cpi	r24, 0x46	; 70
 7aa:	29 f4       	brne	.+10     	; 0x7b6 <main+0x1a6>
			{
				transmission(CMD_TEMP7, TEMP7L, TEMP7H);
 7ac:	60 91 20 01 	lds	r22, 0x0120
 7b0:	40 91 1f 01 	lds	r20, 0x011F
 7b4:	3b c0       	rjmp	.+118    	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_TEMP8)  // Envoie les informations de température du huitième capteur
 7b6:	87 34       	cpi	r24, 0x47	; 71
 7b8:	29 f4       	brne	.+10     	; 0x7c4 <main+0x1b4>
			{
				transmission(CMD_TEMP8, TEMP8L, TEMP8H);
 7ba:	60 91 28 01 	lds	r22, 0x0128
 7be:	40 91 23 01 	lds	r20, 0x0123
 7c2:	34 c0       	rjmp	.+104    	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_PROFONDEUR) // Envoie les informations de pression reçue par le capteur de pression comme indicatif de la profondeur
 7c4:	80 35       	cpi	r24, 0x50	; 80
 7c6:	29 f4       	brne	.+10     	; 0x7d2 <main+0x1c2>
			{
				transmission(CMD_PROFONDEUR, ADC1L, ADC1H);
 7c8:	60 91 16 01 	lds	r22, 0x0116
 7cc:	40 91 39 01 	lds	r20, 0x0139
 7d0:	2d c0       	rjmp	.+90     	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_ADC2) // Envoie les informations du deuxième convertisseur ADC
 7d2:	81 35       	cpi	r24, 0x51	; 81
 7d4:	29 f4       	brne	.+10     	; 0x7e0 <main+0x1d0>
			{
				transmission(CMD_ADC2, ADC2L, ADC2H);
 7d6:	60 91 26 01 	lds	r22, 0x0126
 7da:	40 91 32 01 	lds	r20, 0x0132
 7de:	26 c0       	rjmp	.+76     	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_ADC3) // Envoie les informations du troisième convertisseur ADC
 7e0:	82 35       	cpi	r24, 0x52	; 82
 7e2:	29 f4       	brne	.+10     	; 0x7ee <main+0x1de>
			{
				transmission(CMD_ADC3, ADC3L, ADC3H);
 7e4:	60 91 2e 01 	lds	r22, 0x012E
 7e8:	40 91 2a 01 	lds	r20, 0x012A
 7ec:	1f c0       	rjmp	.+62     	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_ADC4) // Envoie les informations du quatrième convertisseur ADC
 7ee:	83 35       	cpi	r24, 0x53	; 83
 7f0:	29 f4       	brne	.+10     	; 0x7fc <main+0x1ec>
			{
				transmission(CMD_ADC4, ADC4L, ADC4H);
 7f2:	60 91 42 01 	lds	r22, 0x0142
 7f6:	40 91 30 01 	lds	r20, 0x0130
 7fa:	18 c0       	rjmp	.+48     	; 0x82c <main+0x21c>
			}
			else if (data[0]==CMD_SENS_0_POSITIF)
 7fc:	80 39       	cpi	r24, 0x90	; 144
 7fe:	21 f4       	brne	.+8      	; 0x808 <main+0x1f8>
			{
				Sens_0 = 1 ;
 800:	00 93 01 01 	sts	0x0101, r16
				transmission(CMD_SENS_0_POSITIF,Conf_sens0p, 0x00 );
 804:	60 ea       	ldi	r22, 0xA0	; 160
 806:	11 c0       	rjmp	.+34     	; 0x82a <main+0x21a>
			}
			else if (data[0]==CMD_SENS_0_NEGATIF)
 808:	81 39       	cpi	r24, 0x91	; 145
 80a:	21 f4       	brne	.+8      	; 0x814 <main+0x204>
			{
				Sens_0 = 0 ;
 80c:	10 92 01 01 	sts	0x0101, r1
				transmission(CMD_SENS_0_NEGATIF,Conf_sens0n, 0x00 );
 810:	61 ea       	ldi	r22, 0xA1	; 161
 812:	0b c0       	rjmp	.+22     	; 0x82a <main+0x21a>
			}
			else if (data[0]==CMD_SENS_1_POSITIF)
 814:	82 39       	cpi	r24, 0x92	; 146
 816:	21 f4       	brne	.+8      	; 0x820 <main+0x210>
			{
				Sens_1 = 1 ;
 818:	00 93 02 01 	sts	0x0102, r16
				transmission(CMD_SENS_1_POSITIF,Conf_sens1p, 0x00 );
 81c:	62 ea       	ldi	r22, 0xA2	; 162
 81e:	05 c0       	rjmp	.+10     	; 0x82a <main+0x21a>
			}
			else if (data[0]==CMD_SENS_1_NEGATIF)
 820:	83 39       	cpi	r24, 0x93	; 147
 822:	29 f4       	brne	.+10     	; 0x82e <main+0x21e>
			{
				Sens_1 = 0 ;
 824:	10 92 02 01 	sts	0x0102, r1
				transmission(CMD_SENS_1_NEGATIF, Conf_sens1n, 0x00 );
 828:	63 ea       	ldi	r22, 0xA3	; 163
 82a:	40 e0       	ldi	r20, 0x00	; 0
 82c:	7a de       	rcall	.-780    	; 0x522 <transmission>
 82e:	90 e0       	ldi	r25, 0x00	; 0
 830:	07 c0       	rjmp	.+14     	; 0x840 <main+0x230>
					TRANSMIT_STATUT = send_data_3964r(data_to_transmit,2);
				}while (TRANSMIT_STATUT == 0);*/
			}
			for(decalage=0;decalage<=4;decalage++) // Décale les demandes pour supprimer la première et passer au traitement de la demande suivante
			{
				data[decalage]=data[decalage+1];	
 832:	e9 2f       	mov	r30, r25
 834:	f0 e0       	ldi	r31, 0x00	; 0
 836:	ed 5c       	subi	r30, 0xCD	; 205
 838:	fe 4f       	sbci	r31, 0xFE	; 254
 83a:	81 81       	ldd	r24, Z+1	; 0x01
 83c:	80 83       	st	Z, r24
 83e:	9f 5f       	subi	r25, 0xFF	; 255
					data_to_transmit[0]=0x0F;
					data_to_transmit[0]=0xF0;
					TRANSMIT_STATUT = send_data_3964r(data_to_transmit,2);
				}while (TRANSMIT_STATUT == 0);*/
			}
			for(decalage=0;decalage<=4;decalage++) // Décale les demandes pour supprimer la première et passer au traitement de la demande suivante
 840:	95 30       	cpi	r25, 0x05	; 5
 842:	b8 f3       	brcs	.-18     	; 0x832 <main+0x222>
 844:	90 93 2f 01 	sts	0x012F, r25
			{
				data[decalage]=data[decalage+1];	
			}
			data[4] = 0x00 ;
 848:	10 92 37 01 	sts	0x0137, r1
 84c:	f6 ce       	rjmp	.-532    	; 0x63a <main+0x2a>

0000084e <init_timer1>:

#include "timer1.h"

void init_timer1(void)
{
	TCCR1B |= (1<<WGM12);	//CTC
 84e:	e1 e8       	ldi	r30, 0x81	; 129
 850:	f0 e0       	ldi	r31, 0x00	; 0
 852:	80 81       	ld	r24, Z
 854:	88 60       	ori	r24, 0x08	; 8
 856:	80 83       	st	Z, r24
	TIMSK1 |= (1<<OCIE1A);	//Enable OCIE1A
 858:	ef e6       	ldi	r30, 0x6F	; 111
 85a:	f0 e0       	ldi	r31, 0x00	; 0
 85c:	80 81       	ld	r24, Z
 85e:	82 60       	ori	r24, 0x02	; 2
 860:	80 83       	st	Z, r24

	flag_timer1 = FALSE;
 862:	81 e0       	ldi	r24, 0x01	; 1
 864:	80 93 0e 01 	sts	0x010E, r24
}
 868:	08 95       	ret

0000086a <start_timer1>:

//Prescaler 8 => 65536ms MAX
void start_timer1(unsigned int time)
{
	cli();
 86a:	f8 94       	cli
	OCR1A = time;
 86c:	90 93 89 00 	sts	0x0089, r25
 870:	80 93 88 00 	sts	0x0088, r24
	sei();
 874:	78 94       	sei

	//TCCR1B |= (1<<CS11);  //start - Prescaler 8
	TCCR1B |= (1<<CS10) | (1<<CS12);  //start - Prescaler 1024
 876:	e1 e8       	ldi	r30, 0x81	; 129
 878:	f0 e0       	ldi	r31, 0x00	; 0
 87a:	80 81       	ld	r24, Z
 87c:	85 60       	ori	r24, 0x05	; 5
 87e:	80 83       	st	Z, r24
}
 880:	08 95       	ret

00000882 <stop_timer1>:

void stop_timer1(void)
{
	TCCR1B &= 0b11111101;
 882:	e1 e8       	ldi	r30, 0x81	; 129
 884:	f0 e0       	ldi	r31, 0x00	; 0
 886:	80 81       	ld	r24, Z
 888:	8d 7f       	andi	r24, 0xFD	; 253
 88a:	80 83       	st	Z, r24
	//TCCR1B &= 0b11111010;

	//Reset timer
	//Obligation d'arreter les interruptions car le timer est un 16bits => 2 instructions (voir datasheet)
	cli();
 88c:	f8 94       	cli
	TCNT1 = 0;
 88e:	10 92 85 00 	sts	0x0085, r1
 892:	10 92 84 00 	sts	0x0084, r1
	sei();
 896:	78 94       	sei
}
 898:	08 95       	ret

0000089a <__vector_11>:

ISR(TIMER1_COMPA_vect)
{
 89a:	1f 92       	push	r1
 89c:	0f 92       	push	r0
 89e:	0f b6       	in	r0, 0x3f	; 63
 8a0:	0f 92       	push	r0
 8a2:	11 24       	eor	r1, r1
	flag_timer1 = TRUE;	//Force à quitter la boucle de getchar_usart();
 8a4:	10 92 0e 01 	sts	0x010E, r1
}
 8a8:	0f 90       	pop	r0
 8aa:	0f be       	out	0x3f, r0	; 63
 8ac:	0f 90       	pop	r0
 8ae:	1f 90       	pop	r1
 8b0:	18 95       	reti

000008b2 <init_usart>:

//Initialisation de l'usart
void init_usart(unsigned int ubrr)
{
	/*Set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
 8b2:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)ubrr;
 8b6:	80 93 c4 00 	sts	0x00C4, r24
	/*Double speed*/
	UCSR0A = (1<<U2X0);
 8ba:	82 e0       	ldi	r24, 0x02	; 2
 8bc:	80 93 c0 00 	sts	0x00C0, r24
	/*Enable receiver and transmitter */
	UCSR0B |= (1<<TXEN0) | (1<<RXEN0);
 8c0:	e1 ec       	ldi	r30, 0xC1	; 193
 8c2:	f0 e0       	ldi	r31, 0x00	; 0
 8c4:	80 81       	ld	r24, Z
 8c6:	88 61       	ori	r24, 0x18	; 24
 8c8:	80 83       	st	Z, r24
	/* Set frame format: 8data, 1stop bit */
	UCSR0C = (3<<UCSZ00);
 8ca:	86 e0       	ldi	r24, 0x06	; 6
 8cc:	80 93 c2 00 	sts	0x00C2, r24

	flag_usart = FALSE;
 8d0:	81 e0       	ldi	r24, 0x01	; 1
 8d2:	80 93 08 01 	sts	0x0108, r24
}
 8d6:	08 95       	ret

000008d8 <putchar_usart>:

//Permet l'envoi d'un caractère
void putchar_usart(char c)
{
 8d8:	98 2f       	mov	r25, r24
	/* Wait for empty transmit buffer */
	while (!( UCSR0A & (1<<UDRE0)));
 8da:	80 91 c0 00 	lds	r24, 0x00C0
 8de:	85 ff       	sbrs	r24, 5
 8e0:	fc cf       	rjmp	.-8      	; 0x8da <putchar_usart+0x2>
	/* Put data into buffer, sends the data */
	UDR0 = c;
 8e2:	90 93 c6 00 	sts	0x00C6, r25
}
 8e6:	08 95       	ret

000008e8 <getchar_usart>:
//Permet la reception d'un caractère
char getchar_usart(void)
{
	/* Wait for data to be received */
	//Si le flag_timer1 est différent de FALSE, on sort de la boucle
	while ((!(UCSR0A & (1<<RXC0))) && (flag_timer1 == FALSE));
 8e8:	80 91 c0 00 	lds	r24, 0x00C0
 8ec:	87 fd       	sbrc	r24, 7
 8ee:	04 c0       	rjmp	.+8      	; 0x8f8 <getchar_usart+0x10>
 8f0:	80 91 0e 01 	lds	r24, 0x010E
 8f4:	81 30       	cpi	r24, 0x01	; 1
 8f6:	c1 f3       	breq	.-16     	; 0x8e8 <getchar_usart>
	/* Get and return received data from buffer */
	if((UCSR0A & (1<<RXC0)))
 8f8:	80 91 c0 00 	lds	r24, 0x00C0
 8fc:	87 fd       	sbrc	r24, 7
 8fe:	02 c0       	rjmp	.+4      	; 0x904 <getchar_usart+0x1c>
 900:	80 e0       	ldi	r24, 0x00	; 0
 902:	08 95       	ret
	{
		return UDR0;
 904:	80 91 c6 00 	lds	r24, 0x00C6
	}
	else
	{
		return NULL;
	}
}
 908:	08 95       	ret

0000090a <gets_usart>:
		putchar_usart(string[i]);
}

//Permet de recevoir une chaine de caractère sur l'usart
void gets_usart(char string[], unsigned char len)
{
 90a:	fc 01       	movw	r30, r24
 90c:	90 e0       	ldi	r25, 0x00	; 0
 90e:	12 c0       	rjmp	.+36     	; 0x934 <gets_usart+0x2a>
//Permet la reception d'un caractère
char getchar_usart(void)
{
	/* Wait for data to be received */
	//Si le flag_timer1 est différent de FALSE, on sort de la boucle
	while ((!(UCSR0A & (1<<RXC0))) && (flag_timer1 == FALSE));
 910:	80 91 c0 00 	lds	r24, 0x00C0
 914:	87 fd       	sbrc	r24, 7
 916:	04 c0       	rjmp	.+8      	; 0x920 <gets_usart+0x16>
 918:	80 91 0e 01 	lds	r24, 0x010E
 91c:	81 30       	cpi	r24, 0x01	; 1
 91e:	c1 f3       	breq	.-16     	; 0x910 <gets_usart+0x6>
	/* Get and return received data from buffer */
	if((UCSR0A & (1<<RXC0)))
 920:	80 91 c0 00 	lds	r24, 0x00C0
 924:	87 fd       	sbrc	r24, 7
 926:	02 c0       	rjmp	.+4      	; 0x92c <gets_usart+0x22>
 928:	80 e0       	ldi	r24, 0x00	; 0
 92a:	02 c0       	rjmp	.+4      	; 0x930 <gets_usart+0x26>
	{
		return UDR0;
 92c:	80 91 c6 00 	lds	r24, 0x00C6
void gets_usart(char string[], unsigned char len)
{
	unsigned char i;
	
	for(i=0; i<len; i++)
		string[i] = getchar_usart();
 930:	81 93       	st	Z+, r24
//Permet de recevoir une chaine de caractère sur l'usart
void gets_usart(char string[], unsigned char len)
{
	unsigned char i;
	
	for(i=0; i<len; i++)
 932:	9f 5f       	subi	r25, 0xFF	; 255
 934:	96 17       	cp	r25, r22
 936:	60 f3       	brcs	.-40     	; 0x910 <gets_usart+0x6>
		string[i] = getchar_usart();
}
 938:	08 95       	ret

0000093a <puts_usart>:
	}
}

//Permet d'écrire une chaine de caractère sur l'usart
void puts_usart(char string[])
{
 93a:	9c 01       	movw	r18, r24
	unsigned char i;

	for(i=0; i<strlen(string); i++)
 93c:	dc 01       	movw	r26, r24
 93e:	0d 90       	ld	r0, X+
 940:	00 20       	and	r0, r0
 942:	e9 f7       	brne	.-6      	; 0x93e <puts_usart+0x4>
 944:	11 97       	sbiw	r26, 0x01	; 1
 946:	a8 1b       	sub	r26, r24
 948:	b9 0b       	sbc	r27, r25
 94a:	90 e0       	ldi	r25, 0x00	; 0
 94c:	0a c0       	rjmp	.+20     	; 0x962 <puts_usart+0x28>
		putchar_usart(string[i]);
 94e:	e2 0f       	add	r30, r18
 950:	f3 1f       	adc	r31, r19
 952:	40 81       	ld	r20, Z

//Permet l'envoi d'un caractère
void putchar_usart(char c)
{
	/* Wait for empty transmit buffer */
	while (!( UCSR0A & (1<<UDRE0)));
 954:	80 91 c0 00 	lds	r24, 0x00C0
 958:	85 ff       	sbrs	r24, 5
 95a:	fc cf       	rjmp	.-8      	; 0x954 <puts_usart+0x1a>
	/* Put data into buffer, sends the data */
	UDR0 = c;
 95c:	40 93 c6 00 	sts	0x00C6, r20
//Permet d'écrire une chaine de caractère sur l'usart
void puts_usart(char string[])
{
	unsigned char i;

	for(i=0; i<strlen(string); i++)
 960:	9f 5f       	subi	r25, 0xFF	; 255
 962:	e9 2f       	mov	r30, r25
 964:	f0 e0       	ldi	r31, 0x00	; 0
 966:	ea 17       	cp	r30, r26
 968:	fb 07       	cpc	r31, r27
 96a:	88 f3       	brcs	.-30     	; 0x94e <puts_usart+0x14>
		putchar_usart(string[i]);
}
 96c:	08 95       	ret

0000096e <ADC_Init>:
#include <avr/io.h>


void ADC_Init(void)
{
	ADMUX |= (1<<REFS0);									//AVCC comme reference, ADC0 par défault
 96e:	ec e7       	ldi	r30, 0x7C	; 124
 970:	f0 e0       	ldi	r31, 0x00	; 0
 972:	80 81       	ld	r24, Z
 974:	80 64       	ori	r24, 0x40	; 64
 976:	80 83       	st	Z, r24
	ADCSRA |= (1<<ADEN)|(1<<ADPS2)|(1<<ADPS0);				//ADC ENable, ADC interrupt enable, perscaler 32
 978:	ea e7       	ldi	r30, 0x7A	; 122
 97a:	f0 e0       	ldi	r31, 0x00	; 0
 97c:	80 81       	ld	r24, Z
 97e:	85 68       	ori	r24, 0x85	; 133
 980:	80 83       	st	Z, r24
															//ADCSRB = 0  Free running mode
	DIDR0 |= (1<<ADC5D)|(1<<ADC4D);							//Disable PIN ADC4 et 5
 982:	ee e7       	ldi	r30, 0x7E	; 126
 984:	f0 e0       	ldi	r31, 0x00	; 0
 986:	80 81       	ld	r24, Z
 988:	80 63       	ori	r24, 0x30	; 48
 98a:	80 83       	st	Z, r24
}
 98c:	08 95       	ret

0000098e <ADC_Start>:

void ADC_Start(void)
{
	ADCSRA |= (1<<ADSC);									//Start conversion
 98e:	ea e7       	ldi	r30, 0x7A	; 122
 990:	f0 e0       	ldi	r31, 0x00	; 0
 992:	80 81       	ld	r24, Z
 994:	80 64       	ori	r24, 0x40	; 64
 996:	80 83       	st	Z, r24
}
 998:	08 95       	ret

0000099a <ADC_Stop>:

void ADC_Stop(void)
{
	ADCSRA &= ~(1<<ADSC);									//Stop conversion
 99a:	ea e7       	ldi	r30, 0x7A	; 122
 99c:	f0 e0       	ldi	r31, 0x00	; 0
 99e:	80 81       	ld	r24, Z
 9a0:	8f 7b       	andi	r24, 0xBF	; 191
 9a2:	80 83       	st	Z, r24
}
 9a4:	08 95       	ret

000009a6 <ADC_Mux>:

void ADC_Mux(char channel)
{
	switch (channel)
 9a6:	81 30       	cpi	r24, 0x01	; 1
 9a8:	39 f0       	breq	.+14     	; 0x9b8 <ADC_Mux+0x12>
 9aa:	81 30       	cpi	r24, 0x01	; 1
 9ac:	58 f0       	brcs	.+22     	; 0x9c4 <ADC_Mux+0x1e>
 9ae:	82 30       	cpi	r24, 0x02	; 2
 9b0:	29 f0       	breq	.+10     	; 0x9bc <ADC_Mux+0x16>
 9b2:	83 30       	cpi	r24, 0x03	; 3
 9b4:	39 f4       	brne	.+14     	; 0x9c4 <ADC_Mux+0x1e>
 9b6:	04 c0       	rjmp	.+8      	; 0x9c0 <ADC_Mux+0x1a>
	{
		case 0:
			ADMUX = 0b01100000;
			break;
		case 1:
			ADMUX = 0b01100001;
 9b8:	81 e6       	ldi	r24, 0x61	; 97
 9ba:	05 c0       	rjmp	.+10     	; 0x9c6 <ADC_Mux+0x20>
			break;
		case 2:
			ADMUX = 0b01100010;
 9bc:	82 e6       	ldi	r24, 0x62	; 98
 9be:	03 c0       	rjmp	.+6      	; 0x9c6 <ADC_Mux+0x20>
			break;
		case 3:
			ADMUX = 0b01100011;
 9c0:	83 e6       	ldi	r24, 0x63	; 99
 9c2:	01 c0       	rjmp	.+2      	; 0x9c6 <ADC_Mux+0x20>
			break;
		default:
			ADMUX = 0b01100000;
 9c4:	80 e6       	ldi	r24, 0x60	; 96
 9c6:	80 93 7c 00 	sts	0x007C, r24
 9ca:	08 95       	ret

000009cc <TIMER0_20ms_Init>:

//******** TEMPO_0 20ms *********//

void TIMER0_20ms_Init(void)
{
	TCCR0A |= (1<<WGM01);									//Mode CTC du TIMER0
 9cc:	84 b5       	in	r24, 0x24	; 36
 9ce:	82 60       	ori	r24, 0x02	; 2
 9d0:	84 bd       	out	0x24, r24	; 36
	OCR0A = 160;											//Correspond à 20ms
 9d2:	80 ea       	ldi	r24, 0xA0	; 160
 9d4:	87 bd       	out	0x27, r24	; 39
	TIMSK0 |= (1<<OCIE0A);									//Interruptions on compare match
 9d6:	ee e6       	ldi	r30, 0x6E	; 110
 9d8:	f0 e0       	ldi	r31, 0x00	; 0
 9da:	80 81       	ld	r24, Z
 9dc:	82 60       	ori	r24, 0x02	; 2
 9de:	80 83       	st	Z, r24
}
 9e0:	08 95       	ret

000009e2 <TIMER0_20ms_Start>:

void TIMER0_20ms_Start(void)
{
	TCCR0B |= (1<<CS02)|(1<<CS00);							//Prescaler 1024
 9e2:	85 b5       	in	r24, 0x25	; 37
 9e4:	85 60       	ori	r24, 0x05	; 5
 9e6:	85 bd       	out	0x25, r24	; 37
}
 9e8:	08 95       	ret

000009ea <TIMER0_20ms_Stop>:


void TIMER0_20ms_Stop(void)
{
	TCCR0B &= ~(1<<CS02)&~(1<<CS00);						//Stop Tempo
 9ea:	85 b5       	in	r24, 0x25	; 37
 9ec:	8a 7f       	andi	r24, 0xFA	; 250
 9ee:	85 bd       	out	0x25, r24	; 37
}
 9f0:	08 95       	ret

000009f2 <TIMER2_20ms_Init>:

//******** TEMPO_2 20ms *********//

void TIMER2_20ms_Init(void)
{
	TCCR2A |= (1<<WGM01);									//Mode CTC du TIMER2
 9f2:	e0 eb       	ldi	r30, 0xB0	; 176
 9f4:	f0 e0       	ldi	r31, 0x00	; 0
 9f6:	80 81       	ld	r24, Z
 9f8:	82 60       	ori	r24, 0x02	; 2
 9fa:	80 83       	st	Z, r24
	OCR2A = 160;											//Correspond à 20ms
 9fc:	80 ea       	ldi	r24, 0xA0	; 160
 9fe:	80 93 b3 00 	sts	0x00B3, r24
	TIMSK2 |= (1<<OCIE2A);									//Interruptions on compare match
 a02:	e0 e7       	ldi	r30, 0x70	; 112
 a04:	f0 e0       	ldi	r31, 0x00	; 0
 a06:	80 81       	ld	r24, Z
 a08:	82 60       	ori	r24, 0x02	; 2
 a0a:	80 83       	st	Z, r24
}
 a0c:	08 95       	ret

00000a0e <TIMER2_20ms_Start>:

void TIMER2_20ms_Start(void)
{
	TCCR2B |= (1<<CS02)|(1<<CS00);							//Prescaler 1024
 a0e:	e1 eb       	ldi	r30, 0xB1	; 177
 a10:	f0 e0       	ldi	r31, 0x00	; 0
 a12:	80 81       	ld	r24, Z
 a14:	85 60       	ori	r24, 0x05	; 5
 a16:	80 83       	st	Z, r24
}
 a18:	08 95       	ret

00000a1a <TIMER2_20ms_Stop>:


void TIMER2_20ms_Stop(void)
{
	TCCR2B &= ~(1<<CS02)&~(1<<CS00);						//Stop Tempo
 a1a:	e1 eb       	ldi	r30, 0xB1	; 177
 a1c:	f0 e0       	ldi	r31, 0x00	; 0
 a1e:	80 81       	ld	r24, Z
 a20:	8a 7f       	andi	r24, 0xFA	; 250
 a22:	80 83       	st	Z, r24
}
 a24:	08 95       	ret

00000a26 <PCINT_Init>:

//******** PCINTs *********//

void PCINT_Init(void)
{
	EICRA |= (1<<ISC11)|(1<<ISC10)|(1<<ISC01)|(1<<ISC00); 	//Interrupt on INT1 & INT0 on rising edge
 a26:	e9 e6       	ldi	r30, 0x69	; 105
 a28:	f0 e0       	ldi	r31, 0x00	; 0
 a2a:	80 81       	ld	r24, Z
 a2c:	8f 60       	ori	r24, 0x0F	; 15
 a2e:	80 83       	st	Z, r24
}
 a30:	08 95       	ret

00000a32 <PCINT0_ON>:

void PCINT0_ON(void)
{
	EIMSK |= (1<<INT0);										//Autorise interruptions INT0
 a32:	e8 9a       	sbi	0x1d, 0	; 29
}
 a34:	08 95       	ret

00000a36 <PCINT1_ON>:

void PCINT1_ON(void)
{
	EIMSK |= (1<<INT1);										//Autorise interruptions INT1
 a36:	e9 9a       	sbi	0x1d, 1	; 29
}
 a38:	08 95       	ret

00000a3a <PCINT0_OFF>:

void PCINT0_OFF(void)
{
	EIMSK &= ~(1<<INT0);										//Stop interruptions INT0
 a3a:	e8 98       	cbi	0x1d, 0	; 29
}
 a3c:	08 95       	ret

00000a3e <PCINT1_OFF>:

void PCINT1_OFF(void)
{
	EIMSK &= ~(1<<INT1);										//Stop interruptions INT1
 a3e:	e9 98       	cbi	0x1d, 1	; 29
}
 a40:	08 95       	ret

00000a42 <memset>:
 a42:	dc 01       	movw	r26, r24
 a44:	01 c0       	rjmp	.+2      	; 0xa48 <memset+0x6>
 a46:	6d 93       	st	X+, r22
 a48:	41 50       	subi	r20, 0x01	; 1
 a4a:	50 40       	sbci	r21, 0x00	; 0
 a4c:	e0 f7       	brcc	.-8      	; 0xa46 <memset+0x4>
 a4e:	08 95       	ret

00000a50 <_exit>:
 a50:	f8 94       	cli

00000a52 <__stop_program>:
 a52:	ff cf       	rjmp	.-2      	; 0xa52 <__stop_program>
