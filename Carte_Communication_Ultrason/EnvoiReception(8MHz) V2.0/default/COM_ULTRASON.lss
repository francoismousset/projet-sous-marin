
COM_ULTRASON.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000026  00800100  000008e4  00000978  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000008e4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000eb  00800126  00800126  0000099e  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  0000099e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000049f  00000000  00000000  00000a5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000983  00000000  00000000  00000efd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003eb  00000000  00000000  00001880  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000c75  00000000  00000000  00001c6b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000260  00000000  00000000  000028e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000423  00000000  00000000  00002b40  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000032f  00000000  00000000  00002f63  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	40 c0       	rjmp	.+128    	; 0x82 <__ctors_end>
   2:	5a c0       	rjmp	.+180    	; 0xb8 <__bad_interrupt>
   4:	59 c0       	rjmp	.+178    	; 0xb8 <__bad_interrupt>
   6:	58 c0       	rjmp	.+176    	; 0xb8 <__bad_interrupt>
   8:	58 c0       	rjmp	.+176    	; 0xba <__vector_4>
   a:	56 c0       	rjmp	.+172    	; 0xb8 <__bad_interrupt>
   c:	55 c0       	rjmp	.+170    	; 0xb8 <__bad_interrupt>
   e:	7e c0       	rjmp	.+252    	; 0x10c <__vector_7>
  10:	53 c0       	rjmp	.+166    	; 0xb8 <__bad_interrupt>
  12:	52 c0       	rjmp	.+164    	; 0xb8 <__bad_interrupt>
  14:	51 c0       	rjmp	.+162    	; 0xb8 <__bad_interrupt>
  16:	50 c0       	rjmp	.+160    	; 0xb8 <__bad_interrupt>
  18:	4f c0       	rjmp	.+158    	; 0xb8 <__bad_interrupt>
  1a:	4e c0       	rjmp	.+156    	; 0xb8 <__bad_interrupt>
  1c:	63 c0       	rjmp	.+198    	; 0xe4 <__vector_14>
  1e:	4c c0       	rjmp	.+152    	; 0xb8 <__bad_interrupt>
  20:	4b c0       	rjmp	.+150    	; 0xb8 <__bad_interrupt>
  22:	4a c0       	rjmp	.+148    	; 0xb8 <__bad_interrupt>
  24:	d4 c1       	rjmp	.+936    	; 0x3ce <__vector_18>
  26:	48 c0       	rjmp	.+144    	; 0xb8 <__bad_interrupt>
  28:	04 c2       	rjmp	.+1032   	; 0x432 <__vector_20>
  2a:	46 c0       	rjmp	.+140    	; 0xb8 <__bad_interrupt>
  2c:	45 c0       	rjmp	.+138    	; 0xb8 <__bad_interrupt>
  2e:	44 c0       	rjmp	.+136    	; 0xb8 <__bad_interrupt>
  30:	43 c0       	rjmp	.+134    	; 0xb8 <__bad_interrupt>
  32:	42 c0       	rjmp	.+132    	; 0xb8 <__bad_interrupt>
  34:	0d c4       	rjmp	.+2074   	; 0x850 <ConvertAsciiToValue+0x16>
  36:	0a c4       	rjmp	.+2068   	; 0x84c <ConvertAsciiToValue+0x12>
  38:	0d c4       	rjmp	.+2074   	; 0x854 <ConvertAsciiToValue+0x1a>
  3a:	0e c4       	rjmp	.+2076   	; 0x858 <ConvertAsciiToValue+0x1e>
  3c:	0f c4       	rjmp	.+2078   	; 0x85c <ConvertAsciiToValue+0x22>
  3e:	10 c4       	rjmp	.+2080   	; 0x860 <ConvertAsciiToValue+0x26>
  40:	11 c4       	rjmp	.+2082   	; 0x864 <ConvertAsciiToValue+0x2a>
  42:	22 c4       	rjmp	.+2116   	; 0x888 <ConvertAsciiToValue+0x4e>
  44:	21 c4       	rjmp	.+2114   	; 0x888 <ConvertAsciiToValue+0x4e>
  46:	10 c4       	rjmp	.+2080   	; 0x868 <ConvertAsciiToValue+0x2e>
  48:	1d c4       	rjmp	.+2106   	; 0x884 <ConvertAsciiToValue+0x4a>
  4a:	1c c4       	rjmp	.+2104   	; 0x884 <ConvertAsciiToValue+0x4a>
  4c:	1b c4       	rjmp	.+2102   	; 0x884 <ConvertAsciiToValue+0x4a>
  4e:	1a c4       	rjmp	.+2100   	; 0x884 <ConvertAsciiToValue+0x4a>
  50:	19 c4       	rjmp	.+2098   	; 0x884 <ConvertAsciiToValue+0x4a>
  52:	18 c4       	rjmp	.+2096   	; 0x884 <ConvertAsciiToValue+0x4a>
  54:	17 c4       	rjmp	.+2094   	; 0x884 <ConvertAsciiToValue+0x4a>
  56:	0a c4       	rjmp	.+2068   	; 0x86c <ConvertAsciiToValue+0x32>
  58:	0b c4       	rjmp	.+2070   	; 0x870 <ConvertAsciiToValue+0x36>
  5a:	0c c4       	rjmp	.+2072   	; 0x874 <ConvertAsciiToValue+0x3a>
  5c:	0d c4       	rjmp	.+2074   	; 0x878 <ConvertAsciiToValue+0x3e>
  5e:	0e c4       	rjmp	.+2076   	; 0x87c <ConvertAsciiToValue+0x42>
  60:	0f c4       	rjmp	.+2078   	; 0x880 <ConvertAsciiToValue+0x46>
  62:	1e c4       	rjmp	.+2108   	; 0x8a0 <ConvertValueToAscii+0x14>
  64:	1b c4       	rjmp	.+2102   	; 0x89c <ConvertValueToAscii+0x10>
  66:	1e c4       	rjmp	.+2108   	; 0x8a4 <ConvertValueToAscii+0x18>
  68:	1f c4       	rjmp	.+2110   	; 0x8a8 <ConvertValueToAscii+0x1c>
  6a:	20 c4       	rjmp	.+2112   	; 0x8ac <ConvertValueToAscii+0x20>
  6c:	21 c4       	rjmp	.+2114   	; 0x8b0 <ConvertValueToAscii+0x24>
  6e:	22 c4       	rjmp	.+2116   	; 0x8b4 <ConvertValueToAscii+0x28>
  70:	23 c4       	rjmp	.+2118   	; 0x8b8 <ConvertValueToAscii+0x2c>
  72:	24 c4       	rjmp	.+2120   	; 0x8bc <ConvertValueToAscii+0x30>
  74:	25 c4       	rjmp	.+2122   	; 0x8c0 <ConvertValueToAscii+0x34>
  76:	26 c4       	rjmp	.+2124   	; 0x8c4 <ConvertValueToAscii+0x38>
  78:	27 c4       	rjmp	.+2126   	; 0x8c8 <ConvertValueToAscii+0x3c>
  7a:	28 c4       	rjmp	.+2128   	; 0x8cc <ConvertValueToAscii+0x40>
  7c:	29 c4       	rjmp	.+2130   	; 0x8d0 <ConvertValueToAscii+0x44>
  7e:	2a c4       	rjmp	.+2132   	; 0x8d4 <ConvertValueToAscii+0x48>
  80:	2b c4       	rjmp	.+2134   	; 0x8d8 <ConvertValueToAscii+0x4c>

00000082 <__ctors_end>:
  82:	11 24       	eor	r1, r1
  84:	1f be       	out	0x3f, r1	; 63
  86:	cf ef       	ldi	r28, 0xFF	; 255
  88:	d4 e0       	ldi	r29, 0x04	; 4
  8a:	de bf       	out	0x3e, r29	; 62
  8c:	cd bf       	out	0x3d, r28	; 61

0000008e <__do_copy_data>:
  8e:	11 e0       	ldi	r17, 0x01	; 1
  90:	a0 e0       	ldi	r26, 0x00	; 0
  92:	b1 e0       	ldi	r27, 0x01	; 1
  94:	e4 ee       	ldi	r30, 0xE4	; 228
  96:	f8 e0       	ldi	r31, 0x08	; 8
  98:	02 c0       	rjmp	.+4      	; 0x9e <.do_copy_data_start>

0000009a <.do_copy_data_loop>:
  9a:	05 90       	lpm	r0, Z+
  9c:	0d 92       	st	X+, r0

0000009e <.do_copy_data_start>:
  9e:	a6 32       	cpi	r26, 0x26	; 38
  a0:	b1 07       	cpc	r27, r17
  a2:	d9 f7       	brne	.-10     	; 0x9a <.do_copy_data_loop>

000000a4 <__do_clear_bss>:
  a4:	12 e0       	ldi	r17, 0x02	; 2
  a6:	a6 e2       	ldi	r26, 0x26	; 38
  a8:	b1 e0       	ldi	r27, 0x01	; 1
  aa:	01 c0       	rjmp	.+2      	; 0xae <.do_clear_bss_start>

000000ac <.do_clear_bss_loop>:
  ac:	1d 92       	st	X+, r1

000000ae <.do_clear_bss_start>:
  ae:	a1 31       	cpi	r26, 0x11	; 17
  b0:	b1 07       	cpc	r27, r17
  b2:	e1 f7       	brne	.-8      	; 0xac <.do_clear_bss_loop>
  b4:	94 d0       	rcall	.+296    	; 0x1de <main>
  b6:	14 c4       	rjmp	.+2088   	; 0x8e0 <_exit>

000000b8 <__bad_interrupt>:
  b8:	a3 cf       	rjmp	.-186    	; 0x0 <__vectors>

000000ba <__vector_4>:
// INTERRUPTS
/********************/

// Interruption lors d'un changement de niveau sur le port d'entrée
ISR(PCINT1_vect)
{
  ba:	1f 92       	push	r1
  bc:	0f 92       	push	r0
  be:	0f b6       	in	r0, 0x3f	; 63
  c0:	0f 92       	push	r0
  c2:	11 24       	eor	r1, r1
  c4:	8f 93       	push	r24
	if((Receiving==OFF) && (((PINC)&(1<<PINC0))==0) ) Need_Receiving=ON;
  c6:	80 91 26 01 	lds	r24, 0x0126
  ca:	88 23       	and	r24, r24
  cc:	29 f4       	brne	.+10     	; 0xd8 <__vector_4+0x1e>
  ce:	30 99       	sbic	0x06, 0	; 6
  d0:	03 c0       	rjmp	.+6      	; 0xd8 <__vector_4+0x1e>
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	80 93 27 01 	sts	0x0127, r24
}
  d8:	8f 91       	pop	r24
  da:	0f 90       	pop	r0
  dc:	0f be       	out	0x3f, r0	; 63
  de:	0f 90       	pop	r0
  e0:	1f 90       	pop	r1
  e2:	18 95       	reti

000000e4 <__vector_14>:

// Interruption à la fin du timer
ISR(TIMER0_COMPA_vect)
{
  e4:	1f 92       	push	r1
  e6:	0f 92       	push	r0
  e8:	0f b6       	in	r0, 0x3f	; 63
  ea:	0f 92       	push	r0
  ec:	11 24       	eor	r1, r1
  ee:	8f 93       	push	r24
	if(Receiving == ON) RX600INTREQUEST=ON;
  f0:	80 91 26 01 	lds	r24, 0x0126
  f4:	81 30       	cpi	r24, 0x01	; 1
  f6:	19 f4       	brne	.+6      	; 0xfe <__vector_14+0x1a>
  f8:	80 93 34 01 	sts	0x0134, r24
  fc:	01 c0       	rjmp	.+2      	; 0x100 <__vector_14+0x1c>
	else asm("nop");
  fe:	00 00       	nop
}
 100:	8f 91       	pop	r24
 102:	0f 90       	pop	r0
 104:	0f be       	out	0x3f, r0	; 63
 106:	0f 90       	pop	r0
 108:	1f 90       	pop	r1
 10a:	18 95       	reti

0000010c <__vector_7>:

// Anti-rebond : masque PCIE2 retiré pendant 26 ms
ISR (TIMER2_COMPA_vect)			
{
 10c:	1f 92       	push	r1
 10e:	0f 92       	push	r0
 110:	0f b6       	in	r0, 0x3f	; 63
 112:	0f 92       	push	r0
 114:	11 24       	eor	r1, r1
 116:	8f 93       	push	r24
	if (Sending == ON) TX600INTREQUEST=ON;
 118:	80 91 28 01 	lds	r24, 0x0128
 11c:	81 30       	cpi	r24, 0x01	; 1
 11e:	19 f4       	brne	.+6      	; 0x126 <__vector_7+0x1a>
 120:	80 93 35 01 	sts	0x0135, r24
 124:	01 c0       	rjmp	.+2      	; 0x128 <__vector_7+0x1c>
	else asm("nop");
 126:	00 00       	nop
}
 128:	8f 91       	pop	r24
 12a:	0f 90       	pop	r0
 12c:	0f be       	out	0x3f, r0	; 63
 12e:	0f 90       	pop	r0
 130:	1f 90       	pop	r1
 132:	18 95       	reti

00000134 <chartobit>:
	sei();
}

// conversion d'un caractère en tableau avec les valeurs des bits de ce caractère
void chartobit (unsigned char car, volatile unsigned char tab [])
{
 134:	98 2f       	mov	r25, r24
 136:	fb 01       	movw	r30, r22
    int i = 0;
    
    if ((car & 0x80))
 138:	87 ff       	sbrs	r24, 7
 13a:	03 c0       	rjmp	.+6      	; 0x142 <chartobit+0xe>
    {
        tab [7-i] = 1;
 13c:	81 e0       	ldi	r24, 0x01	; 1
 13e:	87 83       	std	Z+7, r24	; 0x07
 140:	01 c0       	rjmp	.+2      	; 0x144 <chartobit+0x10>
    }
    else
    {
        tab [7-i] = 0;
 142:	17 82       	std	Z+7, r1	; 0x07
    }
    i++;
    if ((car & 0x40))
 144:	96 ff       	sbrs	r25, 6
 146:	03 c0       	rjmp	.+6      	; 0x14e <chartobit+0x1a>
    {
        tab [7-i] = 1;
 148:	81 e0       	ldi	r24, 0x01	; 1
 14a:	86 83       	std	Z+6, r24	; 0x06
 14c:	01 c0       	rjmp	.+2      	; 0x150 <chartobit+0x1c>
    }
    else
    {
        tab [7-i] = 0;
 14e:	16 82       	std	Z+6, r1	; 0x06
    }
    i++;
    if ((car & 0x20))
 150:	95 ff       	sbrs	r25, 5
 152:	03 c0       	rjmp	.+6      	; 0x15a <chartobit+0x26>
    {
        tab [7-i] = 1;
 154:	81 e0       	ldi	r24, 0x01	; 1
 156:	85 83       	std	Z+5, r24	; 0x05
 158:	01 c0       	rjmp	.+2      	; 0x15c <chartobit+0x28>
    }
    else
    {
        tab [7-i] = 0;
 15a:	15 82       	std	Z+5, r1	; 0x05
    }
    i++;
    if ((car & 0x10))
 15c:	94 ff       	sbrs	r25, 4
 15e:	03 c0       	rjmp	.+6      	; 0x166 <chartobit+0x32>
    {
        tab [7-i] = 1;
 160:	81 e0       	ldi	r24, 0x01	; 1
 162:	84 83       	std	Z+4, r24	; 0x04
 164:	01 c0       	rjmp	.+2      	; 0x168 <chartobit+0x34>
    }
    else
    {
        tab [7-i] = 0;
 166:	14 82       	std	Z+4, r1	; 0x04
    }
    i++;
    if ((car & 0x08))
 168:	93 ff       	sbrs	r25, 3
 16a:	03 c0       	rjmp	.+6      	; 0x172 <chartobit+0x3e>
    {
        tab [7-i] = 1;
 16c:	81 e0       	ldi	r24, 0x01	; 1
 16e:	83 83       	std	Z+3, r24	; 0x03
 170:	01 c0       	rjmp	.+2      	; 0x174 <chartobit+0x40>
    }
    else
    {
        tab [7-i] = 0;
 172:	13 82       	std	Z+3, r1	; 0x03
    }
    i++;
    if ((car & 0x04))
 174:	92 ff       	sbrs	r25, 2
 176:	03 c0       	rjmp	.+6      	; 0x17e <chartobit+0x4a>
    {
        tab [7-i] = 1;
 178:	81 e0       	ldi	r24, 0x01	; 1
 17a:	82 83       	std	Z+2, r24	; 0x02
 17c:	01 c0       	rjmp	.+2      	; 0x180 <chartobit+0x4c>
    }
    else
    {
        tab [7-i] = 0;
 17e:	12 82       	std	Z+2, r1	; 0x02
    }
    i++;
    if ((car & 0x02))
 180:	91 ff       	sbrs	r25, 1
 182:	03 c0       	rjmp	.+6      	; 0x18a <chartobit+0x56>
    {
        tab [7-i] = 1;
 184:	81 e0       	ldi	r24, 0x01	; 1
 186:	81 83       	std	Z+1, r24	; 0x01
 188:	01 c0       	rjmp	.+2      	; 0x18c <chartobit+0x58>
    }
    else
    {
        tab [7-i] = 0;
 18a:	11 82       	std	Z+1, r1	; 0x01
    }
    i++;
    if ((car & 0x01))
 18c:	90 ff       	sbrs	r25, 0
 18e:	03 c0       	rjmp	.+6      	; 0x196 <chartobit+0x62>
    {
        tab [7-i] = 1;
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	80 83       	st	Z, r24
 194:	08 95       	ret
    }
    else
    {
        tab [7-i] = 0;
 196:	10 82       	st	Z, r1
 198:	08 95       	ret

0000019a <init>:

// Fonction d'initialisation
void init(void)
{
	unsigned char i;
	for(i=0;i<=5;i++) Data_Received[i] = 0x00;
 19a:	10 92 0b 01 	sts	0x010B, r1
 19e:	10 92 0c 01 	sts	0x010C, r1
 1a2:	10 92 0d 01 	sts	0x010D, r1
 1a6:	10 92 0e 01 	sts	0x010E, r1
 1aa:	10 92 0f 01 	sts	0x010F, r1
 1ae:	10 92 10 01 	sts	0x0110, r1

	cli();							// Désactiver toutes les interruptions
 1b2:	f8 94       	cli

	DDRD = 0b10000110;				// config pour BP1 2 3 et 4 (BP = bouton poussoir)
 1b4:	86 e8       	ldi	r24, 0x86	; 134
 1b6:	8a b9       	out	0x0a, r24	; 10
	sbiBF (PORTD, PORTD3);			// BP0
 1b8:	5b 9a       	sbi	0x0b, 3	; 11
	sbiBF (PORTD, PORTD4);			// BP1
 1ba:	5c 9a       	sbi	0x0b, 4	; 11
	sbiBF (PORTD, PORTD5);			// BP2
 1bc:	5d 9a       	sbi	0x0b, 5	; 11
	sbiBF (PORTD, PORTD6);			// BP3
 1be:	5e 9a       	sbi	0x0b, 6	; 11
	sDDR(DDRD,1);					// mettre port TX en sortie
 1c0:	51 9a       	sbi	0x0a, 1	; 10
	sbiBF(PORTD,0); 				// mettre pull-up sur RX
 1c2:	58 9a       	sbi	0x0b, 0	; 11
	sbiBF(PORTC,0); 				// mettre pull-up sur RX
 1c4:	40 9a       	sbi	0x08, 0	; 8
	sDDR(DDRC,1); 					// mettre port en sortie
 1c6:	39 9a       	sbi	0x07, 1	; 7
	DDRB = 0b00111111;  			// PORTB.6et7 en entrée (quartz)
 1c8:	8f e3       	ldi	r24, 0x3F	; 63
 1ca:	84 b9       	out	0x04, r24	; 4
	sbiBF (PORTB, PINB0);				// communication usart à 600baud non modulé
 1cc:	28 9a       	sbi	0x05, 0	; 5

	USART0_Init_9600();				// initialise le port série 
 1ce:	85 d0       	rcall	.+266    	; 0x2da <USART0_Init_9600>
	Init_Buffers_USART ();			// initialise les buffers de la communication série
 1d0:	a4 d0       	rcall	.+328    	; 0x31a <Init_Buffers_USART>

	init_pcint();					// initialise les interruptions externes
 1d2:	ea d2       	rcall	.+1492   	; 0x7a8 <init_pcint>

	TIMER0_INIT();					// initialise le timer 0
 1d4:	04 d3       	rcall	.+1544   	; 0x7de <TIMER0_INIT>
	TIMER1_INIT ();					// initialiser le timer 1
 1d6:	0a d3       	rcall	.+1556   	; 0x7ec <TIMER1_INIT>
	TIMER2_INIT ();					// initialiser le timer 2
 1d8:	1c d3       	rcall	.+1592   	; 0x812 <TIMER2_INIT>

	sei();
 1da:	78 94       	sei
}
 1dc:	08 95       	ret

000001de <main>:
/********************/
// MAIN FUNCTION
/********************/

int main(void)
{
 1de:	1f 93       	push	r17
	unsigned char k;
	init();
 1e0:	dc df       	rcall	.-72     	; 0x19a <init>
	Buffer_USART_Tx_String("End Init \r");
 1e2:	80 e0       	ldi	r24, 0x00	; 0
 1e4:	91 e0       	ldi	r25, 0x01	; 1
 1e6:	e7 d0       	rcall	.+462    	; 0x3b6 <Buffer_USART_Tx_String>
		if (Rx_Counter != 0 && Sending == 0)
		{
			c = getchar_Buffer ();
			chartobit (c, tableau);
			
			Sending = ON;
 1e8:	11 e0       	ldi	r17, 0x01	; 1
	unsigned char k;
	init();
	Buffer_USART_Tx_String("End Init \r");
	while(1)
	{		
		if(Need_Receiving==ON)
 1ea:	90 91 27 01 	lds	r25, 0x0127
 1ee:	91 30       	cpi	r25, 0x01	; 1
 1f0:	a9 f4       	brne	.+42     	; 0x21c <main+0x3e>
		{
			if( ((PINC)&(1<<PINC0))==0 )
 1f2:	30 99       	sbic	0x06, 0	; 6
 1f4:	10 c0       	rjmp	.+32     	; 0x216 <main+0x38>
			{
				if(Receiving==OFF && Compteur_Data_Received!=10)
 1f6:	80 91 26 01 	lds	r24, 0x0126
 1fa:	88 23       	and	r24, r24
 1fc:	51 f4       	brne	.+20     	; 0x212 <main+0x34>
 1fe:	80 91 29 01 	lds	r24, 0x0129
 202:	8a 30       	cpi	r24, 0x0A	; 10
 204:	31 f0       	breq	.+12     	; 0x212 <main+0x34>
				{
					Receiving = ON;	// indique que la récéption est en cour
 206:	90 93 26 01 	sts	0x0126, r25
					Compteur_Timer = 0;
 20a:	10 92 2a 01 	sts	0x012A, r1
					TIMER0_START();	// Lance le timer0 
 20e:	e3 d2       	rcall	.+1478   	; 0x7d6 <TIMER0_START>
 210:	03 c0       	rjmp	.+6      	; 0x218 <main+0x3a>
				}
				else asm("nop");
 212:	00 00       	nop
 214:	01 c0       	rjmp	.+2      	; 0x218 <main+0x3a>
			}
			else asm("nop");	
 216:	00 00       	nop
			Need_Receiving=OFF;	
 218:	10 92 27 01 	sts	0x0127, r1
		}
		if(RX600INTREQUEST==ON)
 21c:	80 91 34 01 	lds	r24, 0x0134
 220:	81 30       	cpi	r24, 0x01	; 1
 222:	19 f4       	brne	.+6      	; 0x22a <main+0x4c>
		{
			Received_600_baud(); // permet de gérer le nombre d'incrémentation du timer 0 en mode de réception de donnée
 224:	b5 d1       	rcall	.+874    	; 0x590 <Received_600_baud>
			RX600INTREQUEST=OFF;
 226:	10 92 34 01 	sts	0x0134, r1
		}
		if(TX600INTREQUEST==ON)
 22a:	80 91 35 01 	lds	r24, 0x0135
 22e:	81 30       	cpi	r24, 0x01	; 1
 230:	19 f4       	brne	.+6      	; 0x238 <main+0x5a>
		{
			Send_600_baud(); // permet de gérer le nombre d'incrémentation du timer 0 en mode d'envoi de donnée
 232:	40 d1       	rcall	.+640    	; 0x4b4 <Send_600_baud>
			TX600INTREQUEST=OFF;
 234:	10 92 35 01 	sts	0x0135, r1
		}
		if(Compteur_Data_Received != 0) 
 238:	80 91 29 01 	lds	r24, 0x0129
 23c:	88 23       	and	r24, r24
 23e:	91 f0       	breq	.+36     	; 0x264 <main+0x86>
		{
			putchar_Buffer(Data_Received[0]);
 240:	80 91 0b 01 	lds	r24, 0x010B
 244:	98 d0       	rcall	.+304    	; 0x376 <putchar_Buffer>
 246:	eb e0       	ldi	r30, 0x0B	; 11
 248:	f1 e0       	ldi	r31, 0x01	; 1
			for(k=0;k<=10;k++) 
			{
				Data_Received[k]=Data_Received[k+1];
 24a:	81 81       	ldd	r24, Z+1	; 0x01
 24c:	81 93       	st	Z+, r24
			TX600INTREQUEST=OFF;
		}
		if(Compteur_Data_Received != 0) 
		{
			putchar_Buffer(Data_Received[0]);
			for(k=0;k<=10;k++) 
 24e:	81 e0       	ldi	r24, 0x01	; 1
 250:	e6 31       	cpi	r30, 0x16	; 22
 252:	f8 07       	cpc	r31, r24
 254:	d1 f7       	brne	.-12     	; 0x24a <main+0x6c>
			{
				Data_Received[k]=Data_Received[k+1];
			}
			Data_Received[10]=0x00;
 256:	10 92 15 01 	sts	0x0115, r1
			Compteur_Data_Received--;
 25a:	80 91 29 01 	lds	r24, 0x0129
 25e:	81 50       	subi	r24, 0x01	; 1
 260:	80 93 29 01 	sts	0x0129, r24
		}
		if (Rx_Counter != 0 && Sending == 0)
 264:	80 91 38 01 	lds	r24, 0x0138
 268:	88 23       	and	r24, r24
 26a:	09 f4       	brne	.+2      	; 0x26e <main+0x90>
 26c:	be cf       	rjmp	.-132    	; 0x1ea <main+0xc>
 26e:	80 91 28 01 	lds	r24, 0x0128
 272:	88 23       	and	r24, r24
 274:	09 f0       	breq	.+2      	; 0x278 <main+0x9a>
 276:	b9 cf       	rjmp	.-142    	; 0x1ea <main+0xc>
		{
			c = getchar_Buffer ();
 278:	5f d0       	rcall	.+190    	; 0x338 <getchar_Buffer>
 27a:	80 93 1a 01 	sts	0x011A, r24
			chartobit (c, tableau);
 27e:	6b e2       	ldi	r22, 0x2B	; 43
 280:	71 e0       	ldi	r23, 0x01	; 1
 282:	58 df       	rcall	.-336    	; 0x134 <chartobit>
			
			Sending = ON;
 284:	10 93 28 01 	sts	0x0128, r17
			TCNT2 = 0;
 288:	10 92 b2 00 	sts	0x00B2, r1

			OCR1A = valeurf2;
 28c:	80 91 18 01 	lds	r24, 0x0118
 290:	90 91 19 01 	lds	r25, 0x0119
 294:	90 93 89 00 	sts	0x0089, r25
 298:	80 93 88 00 	sts	0x0088, r24
			TIMER2_START();
 29c:	c8 d2       	rcall	.+1424   	; 0x82e <TIMER2_START>
			Index = 0;
 29e:	10 92 33 01 	sts	0x0133, r1
			cbiBF (PORTB, PINB0);
 2a2:	28 98       	cbi	0x05, 0	; 5
 2a4:	a2 cf       	rjmp	.-188    	; 0x1ea <main+0xc>

000002a6 <USART_RX0>:
//CONTENU FONCTIONS EXTERNES

unsigned char USART_RX0( void )
{
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) );
 2a6:	80 91 c0 00 	lds	r24, 0x00C0
 2aa:	87 ff       	sbrs	r24, 7
 2ac:	fc cf       	rjmp	.-8      	; 0x2a6 <USART_RX0>
	/* Get and return received data from buffer */
	return UDR0;
 2ae:	80 91 c6 00 	lds	r24, 0x00C6
}
 2b2:	08 95       	ret

000002b4 <USART_TX0>:

void USART_TX0(char data)
{
 2b4:	98 2f       	mov	r25, r24
    // UDRE Flag , is the transmit buffer UDR) ready to receive new data ? 
	// if UDRE = 1 the buffer is empty
	while (!(UCSR0A & (1<<UDRE0)));
 2b6:	80 91 c0 00 	lds	r24, 0x00C0
 2ba:	85 ff       	sbrs	r24, 5
 2bc:	fc cf       	rjmp	.-8      	; 0x2b6 <USART_TX0+0x2>
	// Put data into buffer, sends the data
    UDR0 = data;
 2be:	90 93 c6 00 	sts	0x00C6, r25
}
 2c2:	08 95       	ret

000002c4 <USART_TX0_STRING>:

void USART_TX0_STRING(char *String)
{
 2c4:	fc 01       	movw	r30, r24
	char Continue = TRUE;
	while (Continue)
	{
		if (*String == 0) Continue = FALSE;
 2c6:	91 91       	ld	r25, Z+

void USART_TX0(char data)
{
    // UDRE Flag , is the transmit buffer UDR) ready to receive new data ? 
	// if UDRE = 1 the buffer is empty
	while (!(UCSR0A & (1<<UDRE0)));
 2c8:	80 91 c0 00 	lds	r24, 0x00C0
 2cc:	85 ff       	sbrs	r24, 5
 2ce:	fc cf       	rjmp	.-8      	; 0x2c8 <USART_TX0_STRING+0x4>
	// Put data into buffer, sends the data
    UDR0 = data;
 2d0:	90 93 c6 00 	sts	0x00C6, r25
}

void USART_TX0_STRING(char *String)
{
	char Continue = TRUE;
	while (Continue)
 2d4:	99 23       	and	r25, r25
 2d6:	b9 f7       	brne	.-18     	; 0x2c6 <USART_TX0_STRING+0x2>
	{
		if (*String == 0) Continue = FALSE;
		USART_TX0(*String++);
	}
}
 2d8:	08 95       	ret

000002da <USART0_Init_9600>:
void USART0_Init_9600(void)
{
	// fréquence horloge = 1000000 Mhz, Si Baudrate = 9600 alors UBRR = 12
	// voir explication DS p155
	// 1xspeed  U2X = 1  (voir DS p170)
	UCSR0A |= (1<<U2X0);
 2da:	e0 ec       	ldi	r30, 0xC0	; 192
 2dc:	f0 e0       	ldi	r31, 0x00	; 0
 2de:	80 81       	ld	r24, Z
 2e0:	82 60       	ori	r24, 0x02	; 2
 2e2:	80 83       	st	Z, r24
	// 9600 baud
	UBRR0 = 103; //259;
 2e4:	87 e6       	ldi	r24, 0x67	; 103
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	90 93 c5 00 	sts	0x00C5, r25
 2ec:	80 93 c4 00 	sts	0x00C4, r24
		// Configuration en émission / réception (DS p172), on utilise l'interruption en RX
	UCSR0B = (1<<RXCIE0)|(1<<TXCIE0)|(0<<UDRIE0)|(1<<RXEN0)|(1<<TXEN0)|(0<<UCSZ02)|(0<<RXB80)|(0<<TXB80);
 2f0:	88 ed       	ldi	r24, 0xD8	; 216
 2f2:	80 93 c1 00 	sts	0x00C1, r24
	// Async. mode, 8 bits, 1 bit de stop, pas de contrôle de parité (voir DS p172)
   	UCSR0C |= (0<<UMSEL01)|(0<<UMSEL00)|(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(1<<UCSZ01)|(1<<UCSZ00)|(0<<UCPOL0);
 2f6:	e2 ec       	ldi	r30, 0xC2	; 194
 2f8:	f0 e0       	ldi	r31, 0x00	; 0
 2fa:	80 81       	ld	r24, Z
 2fc:	86 60       	ori	r24, 0x06	; 6
 2fe:	80 83       	st	Z, r24
	
}
 300:	08 95       	ret

00000302 <Enable_Interrupt_On_RX0>:

void Enable_Interrupt_On_RX0(void)
{
	sbiBF(UCSR0B,RXCIE0);
 302:	e1 ec       	ldi	r30, 0xC1	; 193
 304:	f0 e0       	ldi	r31, 0x00	; 0
 306:	80 81       	ld	r24, Z
 308:	80 68       	ori	r24, 0x80	; 128
 30a:	80 83       	st	Z, r24
}
 30c:	08 95       	ret

0000030e <Disable_Interrupt_On_RX0>:

void Disable_Interrupt_On_RX0(void)
{
	cbiBF(UCSR0B,RXCIE0);
 30e:	e1 ec       	ldi	r30, 0xC1	; 193
 310:	f0 e0       	ldi	r31, 0x00	; 0
 312:	80 81       	ld	r24, Z
 314:	8f 77       	andi	r24, 0x7F	; 127
 316:	80 83       	st	Z, r24
}
 318:	08 95       	ret

0000031a <Init_Buffers_USART>:

// initialise les buffer usart
void Init_Buffers_USART(void)
{
 31a:	e6 e4       	ldi	r30, 0x46	; 70
 31c:	f1 e0       	ldi	r31, 0x01	; 1
	unsigned char i;
	for (i = 0; i< Tx_Buffer_Size+1; i++) Tx_Buffer[i] = 0;		// On fait une boucle et toutes les variables à 0
 31e:	11 92       	st	Z+, r1
 320:	81 e0       	ldi	r24, 0x01	; 1
 322:	eb 3a       	cpi	r30, 0xAB	; 171
 324:	f8 07       	cpc	r31, r24
 326:	d9 f7       	brne	.-10     	; 0x31e <Init_Buffers_USART+0x4>
 328:	eb ea       	ldi	r30, 0xAB	; 171
 32a:	f1 e0       	ldi	r31, 0x01	; 1
	for (i = 0; i< Rx_Buffer_Size+1; i++) Rx_Buffer[i] = 0;
 32c:	11 92       	st	Z+, r1
 32e:	82 e0       	ldi	r24, 0x02	; 2
 330:	e0 31       	cpi	r30, 0x10	; 16
 332:	f8 07       	cpc	r31, r24
 334:	d9 f7       	brne	.-10     	; 0x32c <Init_Buffers_USART+0x12>
}
 336:	08 95       	ret

00000338 <getchar_Buffer>:
// fonction qui va chercher une valeur dans le buffer rx
char getchar_Buffer(void)
{
	char c=' ';
	//while (Rx_Counter == 0);
	if(Rx_Counter == 0) return(0xFF);
 338:	80 91 38 01 	lds	r24, 0x0138
 33c:	88 23       	and	r24, r24
 33e:	11 f4       	brne	.+4      	; 0x344 <getchar_Buffer+0xc>
 340:	ef ef       	ldi	r30, 0xFF	; 255
 342:	17 c0       	rjmp	.+46     	; 0x372 <getchar_Buffer+0x3a>
	c = Rx_Buffer[Rx_Rd_Index];
 344:	80 91 37 01 	lds	r24, 0x0137
 348:	e8 2f       	mov	r30, r24
 34a:	f0 e0       	ldi	r31, 0x00	; 0
 34c:	e5 55       	subi	r30, 0x55	; 85
 34e:	fe 4f       	sbci	r31, 0xFE	; 254
 350:	e0 81       	ld	r30, Z
	if (++Rx_Rd_Index > Rx_Buffer_Size) Rx_Rd_Index = 0;
 352:	8f 5f       	subi	r24, 0xFF	; 255
 354:	80 93 37 01 	sts	0x0137, r24
 358:	85 36       	cpi	r24, 0x65	; 101
 35a:	10 f0       	brcs	.+4      	; 0x360 <getchar_Buffer+0x28>
 35c:	10 92 37 01 	sts	0x0137, r1
	if (Rx_Counter)
 360:	80 91 38 01 	lds	r24, 0x0138
 364:	88 23       	and	r24, r24
 366:	29 f0       	breq	.+10     	; 0x372 <getchar_Buffer+0x3a>
	{
		Rx_Counter--;
 368:	80 91 38 01 	lds	r24, 0x0138
 36c:	81 50       	subi	r24, 0x01	; 1
 36e:	80 93 38 01 	sts	0x0138, r24
	}
	return c;
}
 372:	8e 2f       	mov	r24, r30
 374:	08 95       	ret

00000376 <putchar_Buffer>:
	}
}

// mettre un caractère dans le buffer tx
void putchar_Buffer(char c)
{
 376:	28 2f       	mov	r18, r24
	char Ammorce = 0;
	while(Tx_Counter > (Tx_Buffer_Size-1));		//Attendre tant que le buffer est rempli
 378:	90 91 3c 01 	lds	r25, 0x013C
 37c:	94 36       	cpi	r25, 0x64	; 100
 37e:	c8 f4       	brcc	.+50     	; 0x3b2 <putchar_Buffer+0x3c>
	if (Tx_Counter ==0) Ammorce = 1;			//Si le buffer est vide il fait ammorcer le processus d'interruptions
	Tx_Buffer[Tx_Wr_Index++] = c;	
 380:	80 91 3a 01 	lds	r24, 0x013A
 384:	e8 2f       	mov	r30, r24
 386:	f0 e0       	ldi	r31, 0x00	; 0
 388:	ea 5b       	subi	r30, 0xBA	; 186
 38a:	fe 4f       	sbci	r31, 0xFE	; 254
 38c:	20 83       	st	Z, r18
 38e:	8f 5f       	subi	r24, 0xFF	; 255
 390:	80 93 3a 01 	sts	0x013A, r24
	if (Tx_Wr_Index > Tx_Buffer_Size) Tx_Wr_Index = 0;
 394:	85 36       	cpi	r24, 0x65	; 101
 396:	10 f0       	brcs	.+4      	; 0x39c <putchar_Buffer+0x26>
 398:	10 92 3a 01 	sts	0x013A, r1
	Tx_Counter++;
 39c:	9f 5f       	subi	r25, 0xFF	; 255
 39e:	90 93 3c 01 	sts	0x013C, r25
 3a2:	91 50       	subi	r25, 0x01	; 1
	if (Ammorce)
 3a4:	39 f4       	brne	.+14     	; 0x3b4 <putchar_Buffer+0x3e>
	{
		Prime_Interrupt =1;						// Cette variable va être utilisé dans l'interruption (ammorce est local)						
 3a6:	81 e0       	ldi	r24, 0x01	; 1
 3a8:	80 93 45 01 	sts	0x0145, r24
		UDR0 = c;								// On amorce
 3ac:	20 93 c6 00 	sts	0x00C6, r18
 3b0:	08 95       	ret
 3b2:	ff cf       	rjmp	.-2      	; 0x3b2 <putchar_Buffer+0x3c>
 3b4:	08 95       	ret

000003b6 <Buffer_USART_Tx_String>:
	return c;
}

// Ecrire une string dans le buffer (relais activé ou désactivé)
void Buffer_USART_Tx_String(char *String)	
{
 3b6:	cf 93       	push	r28
 3b8:	df 93       	push	r29
 3ba:	ec 01       	movw	r28, r24
 3bc:	02 c0       	rjmp	.+4      	; 0x3c2 <Buffer_USART_Tx_String+0xc>
	char Continue = TRUE;
	while (Continue)
	{
		if(*String==0) Continue = FALSE;
		else putchar_Buffer(*String++);
 3be:	21 96       	adiw	r28, 0x01	; 1
 3c0:	da df       	rcall	.-76     	; 0x376 <putchar_Buffer>
void Buffer_USART_Tx_String(char *String)	
{
	char Continue = TRUE;
	while (Continue)
	{
		if(*String==0) Continue = FALSE;
 3c2:	88 81       	ld	r24, Y
 3c4:	88 23       	and	r24, r24
 3c6:	d9 f7       	brne	.-10     	; 0x3be <Buffer_USART_Tx_String+0x8>
		else putchar_Buffer(*String++);
	}
}
 3c8:	df 91       	pop	r29
 3ca:	cf 91       	pop	r28
 3cc:	08 95       	ret

000003ce <__vector_18>:
/********************/
/*INTERRUPTION*/
/********************/

ISR(USART_RX_vect)  // interruption qui enregistre une nouvelle valeur dans le buffer rx
{
 3ce:	1f 92       	push	r1
 3d0:	0f 92       	push	r0
 3d2:	0f b6       	in	r0, 0x3f	; 63
 3d4:	0f 92       	push	r0
 3d6:	11 24       	eor	r1, r1
 3d8:	8f 93       	push	r24
 3da:	ef 93       	push	r30
 3dc:	ff 93       	push	r31
	
	Rx_Buffer[Rx_Wr_Index] = UDR0;
 3de:	e0 91 36 01 	lds	r30, 0x0136
 3e2:	80 91 c6 00 	lds	r24, 0x00C6
 3e6:	f0 e0       	ldi	r31, 0x00	; 0
 3e8:	e5 55       	subi	r30, 0x55	; 85
 3ea:	fe 4f       	sbci	r31, 0xFE	; 254
 3ec:	80 83       	st	Z, r24
	if (++Rx_Wr_Index > Rx_Buffer_Size) Rx_Wr_Index = 0;
 3ee:	80 91 36 01 	lds	r24, 0x0136
 3f2:	8f 5f       	subi	r24, 0xFF	; 255
 3f4:	80 93 36 01 	sts	0x0136, r24
 3f8:	80 91 36 01 	lds	r24, 0x0136
 3fc:	85 36       	cpi	r24, 0x65	; 101
 3fe:	10 f0       	brcs	.+4      	; 0x404 <__vector_18+0x36>
 400:	10 92 36 01 	sts	0x0136, r1
	if (++Rx_Counter > Rx_Buffer_Size)
 404:	80 91 38 01 	lds	r24, 0x0138
 408:	8f 5f       	subi	r24, 0xFF	; 255
 40a:	80 93 38 01 	sts	0x0138, r24
 40e:	80 91 38 01 	lds	r24, 0x0138
 412:	85 36       	cpi	r24, 0x65	; 101
 414:	30 f0       	brcs	.+12     	; 0x422 <__vector_18+0x54>
	{
		Rx_Counter = Rx_Buffer_Size;
 416:	84 e6       	ldi	r24, 0x64	; 100
 418:	80 93 38 01 	sts	0x0138, r24
		Rx_Buffer_Overflow = 1;
 41c:	81 e0       	ldi	r24, 0x01	; 1
 41e:	80 93 39 01 	sts	0x0139, r24
	}
}
 422:	ff 91       	pop	r31
 424:	ef 91       	pop	r30
 426:	8f 91       	pop	r24
 428:	0f 90       	pop	r0
 42a:	0f be       	out	0x3f, r0	; 63
 42c:	0f 90       	pop	r0
 42e:	1f 90       	pop	r1
 430:	18 95       	reti

00000432 <__vector_20>:

ISR(USART_TX_vect) // interruption pour envoyer le caractère suivant du buffer
{
 432:	1f 92       	push	r1
 434:	0f 92       	push	r0
 436:	0f b6       	in	r0, 0x3f	; 63
 438:	0f 92       	push	r0
 43a:	11 24       	eor	r1, r1
 43c:	2f 93       	push	r18
 43e:	8f 93       	push	r24
 440:	9f 93       	push	r25
 442:	ef 93       	push	r30
 444:	ff 93       	push	r31
	if(Tx_Counter != 0)
 446:	90 91 3c 01 	lds	r25, 0x013C
 44a:	99 23       	and	r25, r25
 44c:	49 f1       	breq	.+82     	; 0x4a0 <__vector_20+0x6e>
	{
		if(Prime_Interrupt == 1)			// Mise à 1 dans la fonction putchar
 44e:	80 91 45 01 	lds	r24, 0x0145
 452:	81 30       	cpi	r24, 0x01	; 1
 454:	71 f4       	brne	.+28     	; 0x472 <__vector_20+0x40>
		{
			Prime_Interrupt = 0;
 456:	10 92 45 01 	sts	0x0145, r1
			if(++Tx_Rd_Index > Tx_Buffer_Size) Tx_Rd_Index = 0;
 45a:	80 91 3b 01 	lds	r24, 0x013B
 45e:	8f 5f       	subi	r24, 0xFF	; 255
 460:	80 93 3b 01 	sts	0x013B, r24
 464:	85 36       	cpi	r24, 0x65	; 101
 466:	10 f0       	brcs	.+4      	; 0x46c <__vector_20+0x3a>
 468:	10 92 3b 01 	sts	0x013B, r1
			Tx_Counter--;
 46c:	91 50       	subi	r25, 0x01	; 1
 46e:	90 93 3c 01 	sts	0x013C, r25
		}
		if(Tx_Counter != 0)
 472:	20 91 3c 01 	lds	r18, 0x013C
 476:	22 23       	and	r18, r18
 478:	99 f0       	breq	.+38     	; 0x4a0 <__vector_20+0x6e>
		{
			UDR0 = Tx_Buffer[Tx_Rd_Index];
 47a:	80 91 3b 01 	lds	r24, 0x013B
 47e:	e8 2f       	mov	r30, r24
 480:	f0 e0       	ldi	r31, 0x00	; 0
 482:	ea 5b       	subi	r30, 0xBA	; 186
 484:	fe 4f       	sbci	r31, 0xFE	; 254
 486:	90 81       	ld	r25, Z
 488:	90 93 c6 00 	sts	0x00C6, r25
			if(++Tx_Rd_Index > Tx_Buffer_Size) Tx_Rd_Index = 0;
 48c:	8f 5f       	subi	r24, 0xFF	; 255
 48e:	80 93 3b 01 	sts	0x013B, r24
 492:	85 36       	cpi	r24, 0x65	; 101
 494:	10 f0       	brcs	.+4      	; 0x49a <__vector_20+0x68>
 496:	10 92 3b 01 	sts	0x013B, r1
			Tx_Counter--;
 49a:	21 50       	subi	r18, 0x01	; 1
 49c:	20 93 3c 01 	sts	0x013C, r18
		}
	}
}
 4a0:	ff 91       	pop	r31
 4a2:	ef 91       	pop	r30
 4a4:	9f 91       	pop	r25
 4a6:	8f 91       	pop	r24
 4a8:	2f 91       	pop	r18
 4aa:	0f 90       	pop	r0
 4ac:	0f be       	out	0x3f, r0	; 63
 4ae:	0f 90       	pop	r0
 4b0:	1f 90       	pop	r1
 4b2:	18 95       	reti

000004b4 <Send_600_baud>:


// permet l'envoi à 600 baud
void Send_600_baud(void)
{
	nbreappel ++;
 4b4:	80 91 40 01 	lds	r24, 0x0140
 4b8:	8f 5f       	subi	r24, 0xFF	; 255
 4ba:	80 93 40 01 	sts	0x0140, r24
	if (nbreappel == COMSP && Index <=7)
 4be:	80 31       	cpi	r24, 0x10	; 16
 4c0:	19 f5       	brne	.+70     	; 0x508 <__stack+0x9>
 4c2:	20 91 33 01 	lds	r18, 0x0133
 4c6:	28 30       	cpi	r18, 0x08	; 8
 4c8:	f8 f4       	brcc	.+62     	; 0x508 <__stack+0x9>
	{
		if (tableau[Index] == 0)
 4ca:	e2 2f       	mov	r30, r18
 4cc:	f0 e0       	ldi	r31, 0x00	; 0
 4ce:	e5 5d       	subi	r30, 0xD5	; 213
 4d0:	fe 4f       	sbci	r31, 0xFE	; 254
 4d2:	80 81       	ld	r24, Z
 4d4:	88 23       	and	r24, r24
 4d6:	51 f4       	brne	.+20     	; 0x4ec <Send_600_baud+0x38>
		{
			OCR1A = valeurf2;
 4d8:	80 91 18 01 	lds	r24, 0x0118
 4dc:	90 91 19 01 	lds	r25, 0x0119
 4e0:	90 93 89 00 	sts	0x0089, r25
 4e4:	80 93 88 00 	sts	0x0088, r24
			cbiBF (PORTB, PINB0);
 4e8:	28 98       	cbi	0x05, 0	; 5
 4ea:	09 c0       	rjmp	.+18     	; 0x4fe <Send_600_baud+0x4a>
		}
		else
		{
			OCR1A = valeurf1;
 4ec:	80 91 16 01 	lds	r24, 0x0116
 4f0:	90 91 17 01 	lds	r25, 0x0117
 4f4:	90 93 89 00 	sts	0x0089, r25
 4f8:	80 93 88 00 	sts	0x0088, r24
			sbiBF (PORTB, PINB0);
 4fc:	28 9a       	sbi	0x05, 0	; 5
		}
		Index ++;
 4fe:	2f 5f       	subi	r18, 0xFF	; 255
 500:	20 93 33 01 	sts	0x0133, r18
		nbreappel = 0;
 504:	10 92 40 01 	sts	0x0140, r1
	}
	if (nbreappel == COMSP && Index == 8)
 508:	80 91 40 01 	lds	r24, 0x0140
 50c:	80 31       	cpi	r24, 0x10	; 16
 50e:	91 f4       	brne	.+36     	; 0x534 <__stack+0x35>
 510:	80 91 33 01 	lds	r24, 0x0133
 514:	88 30       	cpi	r24, 0x08	; 8
 516:	71 f4       	brne	.+28     	; 0x534 <__stack+0x35>
	{
		OCR1A = valeurf1;
 518:	80 91 16 01 	lds	r24, 0x0116
 51c:	90 91 17 01 	lds	r25, 0x0117
 520:	90 93 89 00 	sts	0x0089, r25
 524:	80 93 88 00 	sts	0x0088, r24
		sbiBF (PORTB, PINB0);
 528:	28 9a       	sbi	0x05, 0	; 5
		Index ++;
 52a:	89 e0       	ldi	r24, 0x09	; 9
 52c:	80 93 33 01 	sts	0x0133, r24
		nbreappel = 0;
 530:	10 92 40 01 	sts	0x0140, r1
	}
	if (nbreappel == COMSPD && Index == 9)
 534:	80 91 40 01 	lds	r24, 0x0140
 538:	8c 31       	cpi	r24, 0x1C	; 28
 53a:	59 f4       	brne	.+22     	; 0x552 <__stack+0x53>
 53c:	80 91 33 01 	lds	r24, 0x0133
 540:	89 30       	cpi	r24, 0x09	; 9
 542:	39 f4       	brne	.+14     	; 0x552 <__stack+0x53>
	{
		Index = 0;
 544:	10 92 33 01 	sts	0x0133, r1
		Sending = OFF;
 548:	10 92 28 01 	sts	0x0128, r1
		nbreappel = 0;
 54c:	10 92 40 01 	sts	0x0140, r1
		TIMER2_STOP();
 550:	69 d1       	rcall	.+722    	; 0x824 <TIMER2_STOP>
 552:	08 95       	ret

00000554 <com_test>:


// Fonction de test qui retourne une valeur
unsigned char com_test(void)
{
	Compteur_Timer = 0;
 554:	10 92 2a 01 	sts	0x012A, r1
	TIMER0_START();	// Lance le timer0 
 558:	3e d1       	rcall	.+636    	; 0x7d6 <TIMER0_START>
	do
	{
		asm("nop");
	}while(Compteur_Timer!=COMSPEED);
 55a:	80 91 2a 01 	lds	r24, 0x012A
{
	Compteur_Timer = 0;
	TIMER0_START();	// Lance le timer0 
	do
	{
		asm("nop");
 55e:	00 00       	nop
	}while(Compteur_Timer!=COMSPEED);
 560:	84 30       	cpi	r24, 0x04	; 4
 562:	e9 f7       	brne	.-6      	; 0x55e <com_test+0xa>
	TIMER0_STOP();
 564:	35 d1       	rcall	.+618    	; 0x7d0 <TIMER0_STOP>
	test++;
 566:	80 91 10 02 	lds	r24, 0x0210
 56a:	8f 5f       	subi	r24, 0xFF	; 255
 56c:	80 93 10 02 	sts	0x0210, r24
	if(test==1) return(0x01);
 570:	81 30       	cpi	r24, 0x01	; 1
 572:	69 f0       	breq	.+26     	; 0x58e <com_test+0x3a>
	else if (test==2) return(0x02);
 574:	82 30       	cpi	r24, 0x02	; 2
 576:	59 f0       	breq	.+22     	; 0x58e <com_test+0x3a>
	else if (test==4) return(0x04);
 578:	84 30       	cpi	r24, 0x04	; 4
 57a:	49 f0       	breq	.+18     	; 0x58e <com_test+0x3a>
	else if (test==5) return(0x05);
 57c:	85 30       	cpi	r24, 0x05	; 5
 57e:	39 f0       	breq	.+14     	; 0x58e <com_test+0x3a>
	else if (test==6) return(0x06);
 580:	86 30       	cpi	r24, 0x06	; 6
 582:	29 f0       	breq	.+10     	; 0x58e <com_test+0x3a>
	else if (test==8) return(0x08);
 584:	88 30       	cpi	r24, 0x08	; 8
 586:	11 f0       	breq	.+4      	; 0x58c <com_test+0x38>
 588:	8f ef       	ldi	r24, 0xFF	; 255
 58a:	08 95       	ret
 58c:	88 e0       	ldi	r24, 0x08	; 8
	else return(0xFF);
}
 58e:	08 95       	ret

00000590 <Received_600_baud>:
// FUNCTIONS

// Permet la réception d'un octet sur PINC0. le nombre de baud dépend de COMSPEED (voir .h)
void Received_600_baud(void)
{
	Compteur_Timer++;
 590:	90 91 2a 01 	lds	r25, 0x012A
 594:	9f 5f       	subi	r25, 0xFF	; 255
 596:	90 93 2a 01 	sts	0x012A, r25
	/********** START BIT **********/
	if(Receiv_Statut==0 || Receiv_Statut==1 || Receiv_Statut==2)
 59a:	80 91 42 01 	lds	r24, 0x0142
 59e:	83 30       	cpi	r24, 0x03	; 3
 5a0:	78 f4       	brcc	.+30     	; 0x5c0 <Received_600_baud+0x30>
	{
		if(Compteur_Timer==COMSPEED) 
 5a2:	94 30       	cpi	r25, 0x04	; 4
 5a4:	59 f4       	brne	.+22     	; 0x5bc <Received_600_baud+0x2c>
		{
			Compteur_Timer=0;
 5a6:	10 92 2a 01 	sts	0x012A, r1
			Receiv_Statut++;
 5aa:	8f 5f       	subi	r24, 0xFF	; 255
 5ac:	80 93 42 01 	sts	0x0142, r24
			Compteur_Bit=0;
 5b0:	10 92 43 01 	sts	0x0143, r1
			if(((PINC)&(1<<PINC0))!=0)
 5b4:	30 99       	sbic	0x06, 0	; 6
 5b6:	90 c0       	rjmp	.+288    	; 0x6d8 <Received_600_baud+0x148>
			{
	 			TIMER0_STOP();
				Receiving=OFF;
				return;
			}
			else asm("nop");
 5b8:	00 00       	nop
 5ba:	39 c0       	rjmp	.+114    	; 0x62e <Received_600_baud+0x9e>
		}
		else asm("nop");
 5bc:	00 00       	nop
 5be:	37 c0       	rjmp	.+110    	; 0x62e <Received_600_baud+0x9e>
	}

	/********** DATA **********/
	else if(Receiv_Statut==3)
 5c0:	83 30       	cpi	r24, 0x03	; 3
 5c2:	81 f4       	brne	.+32     	; 0x5e4 <Received_600_baud+0x54>
	{
		if(Compteur_Timer==COMSPEEED)
 5c4:	98 30       	cpi	r25, 0x08	; 8
 5c6:	99 f5       	brne	.+102    	; 0x62e <Received_600_baud+0x9e>
		{
			Compteur_Timer=0;
 5c8:	10 92 2a 01 	sts	0x012A, r1
			Receiv_Statut++;
 5cc:	84 e0       	ldi	r24, 0x04	; 4
 5ce:	80 93 42 01 	sts	0x0142, r24
			if(((PINC)&(1<<PINC0))==0) Data_Verif[0]=0;
 5d2:	30 99       	sbic	0x06, 0	; 6
 5d4:	03 c0       	rjmp	.+6      	; 0x5dc <Received_600_baud+0x4c>
 5d6:	10 92 23 01 	sts	0x0123, r1
 5da:	29 c0       	rjmp	.+82     	; 0x62e <Received_600_baud+0x9e>
			else Data_Verif[0]=1;
 5dc:	81 e0       	ldi	r24, 0x01	; 1
 5de:	80 93 23 01 	sts	0x0123, r24
 5e2:	25 c0       	rjmp	.+74     	; 0x62e <Received_600_baud+0x9e>
		}
	}
	else if(Receiv_Statut==4)
 5e4:	84 30       	cpi	r24, 0x04	; 4
 5e6:	81 f4       	brne	.+32     	; 0x608 <Received_600_baud+0x78>
	{
		if(Compteur_Timer==COMSPEED)
 5e8:	94 30       	cpi	r25, 0x04	; 4
 5ea:	09 f5       	brne	.+66     	; 0x62e <Received_600_baud+0x9e>
		{
			Compteur_Timer=0;
 5ec:	10 92 2a 01 	sts	0x012A, r1
			Receiv_Statut++;
 5f0:	85 e0       	ldi	r24, 0x05	; 5
 5f2:	80 93 42 01 	sts	0x0142, r24
			if(((PINC)&(1<<PINC0))==0) Data_Verif[1]=0;
 5f6:	30 99       	sbic	0x06, 0	; 6
 5f8:	03 c0       	rjmp	.+6      	; 0x600 <Received_600_baud+0x70>
 5fa:	10 92 24 01 	sts	0x0124, r1
 5fe:	17 c0       	rjmp	.+46     	; 0x62e <Received_600_baud+0x9e>
			else Data_Verif[1]=1;
 600:	81 e0       	ldi	r24, 0x01	; 1
 602:	80 93 24 01 	sts	0x0124, r24
 606:	13 c0       	rjmp	.+38     	; 0x62e <Received_600_baud+0x9e>
		}
	}
	else if(Receiv_Statut==5)
 608:	85 30       	cpi	r24, 0x05	; 5
 60a:	81 f4       	brne	.+32     	; 0x62c <Received_600_baud+0x9c>
	{
		if(Compteur_Timer==COMSPEED)
 60c:	94 30       	cpi	r25, 0x04	; 4
 60e:	79 f4       	brne	.+30     	; 0x62e <Received_600_baud+0x9e>
		{
			Compteur_Timer=0;
 610:	10 92 2a 01 	sts	0x012A, r1
			Receiv_Statut++;
 614:	86 e0       	ldi	r24, 0x06	; 6
 616:	80 93 42 01 	sts	0x0142, r24
			if(((PINC)&(1<<PINC0))==0) Data_Verif[2]=0;
 61a:	30 99       	sbic	0x06, 0	; 6
 61c:	03 c0       	rjmp	.+6      	; 0x624 <Received_600_baud+0x94>
 61e:	10 92 25 01 	sts	0x0125, r1
 622:	05 c0       	rjmp	.+10     	; 0x62e <Received_600_baud+0x9e>
			else Data_Verif[2]=1;
 624:	81 e0       	ldi	r24, 0x01	; 1
 626:	80 93 25 01 	sts	0x0125, r24
 62a:	01 c0       	rjmp	.+2      	; 0x62e <Received_600_baud+0x9e>
		}
	}
	else asm("nop");
 62c:	00 00       	nop
	if(Receiv_Statut==6)
 62e:	80 91 42 01 	lds	r24, 0x0142
 632:	86 30       	cpi	r24, 0x06	; 6
 634:	81 f5       	brne	.+96     	; 0x696 <Received_600_baud+0x106>
	{
		// Vérification de la valeur du bit et inscription dans le tableau DATA[]
		if(((Data_Verif[0]==0)&&(Data_Verif[1]==0))||((Data_Verif[1]==0)&&(Data_Verif[2]==0))||((Data_Verif[2]==0)&&(Data_Verif[0]==0)))
 636:	90 91 23 01 	lds	r25, 0x0123
 63a:	99 23       	and	r25, r25
 63c:	21 f4       	brne	.+8      	; 0x646 <Received_600_baud+0xb6>
 63e:	80 91 24 01 	lds	r24, 0x0124
 642:	88 23       	and	r24, r24
 644:	71 f0       	breq	.+28     	; 0x662 <Received_600_baud+0xd2>
 646:	80 91 24 01 	lds	r24, 0x0124
 64a:	88 23       	and	r24, r24
 64c:	21 f4       	brne	.+8      	; 0x656 <Received_600_baud+0xc6>
 64e:	80 91 25 01 	lds	r24, 0x0125
 652:	88 23       	and	r24, r24
 654:	31 f0       	breq	.+12     	; 0x662 <Received_600_baud+0xd2>
 656:	80 91 25 01 	lds	r24, 0x0125
 65a:	88 23       	and	r24, r24
 65c:	49 f4       	brne	.+18     	; 0x670 <Received_600_baud+0xe0>
 65e:	99 23       	and	r25, r25
 660:	39 f4       	brne	.+14     	; 0x670 <Received_600_baud+0xe0>
		{
			Data_com[Compteur_Bit]=0;
 662:	e0 91 43 01 	lds	r30, 0x0143
 666:	f0 e0       	ldi	r31, 0x00	; 0
 668:	e5 5e       	subi	r30, 0xE5	; 229
 66a:	fe 4f       	sbci	r31, 0xFE	; 254
 66c:	10 82       	st	Z, r1
 66e:	07 c0       	rjmp	.+14     	; 0x67e <Received_600_baud+0xee>
		}
		else Data_com[Compteur_Bit]=1;
 670:	e0 91 43 01 	lds	r30, 0x0143
 674:	f0 e0       	ldi	r31, 0x00	; 0
 676:	e5 5e       	subi	r30, 0xE5	; 229
 678:	fe 4f       	sbci	r31, 0xFE	; 254
 67a:	81 e0       	ldi	r24, 0x01	; 1
 67c:	80 83       	st	Z, r24
		// Augmentation du compteur du nombre de bit déjà acquis
		Compteur_Bit++;
 67e:	80 91 43 01 	lds	r24, 0x0143
 682:	8f 5f       	subi	r24, 0xFF	; 255
 684:	80 93 43 01 	sts	0x0143, r24
		if(Compteur_Bit!=8) Receiv_Statut = 3;
 688:	88 30       	cpi	r24, 0x08	; 8
 68a:	11 f0       	breq	.+4      	; 0x690 <Received_600_baud+0x100>
 68c:	83 e0       	ldi	r24, 0x03	; 3
 68e:	01 c0       	rjmp	.+2      	; 0x692 <Received_600_baud+0x102>
		else Receiv_Statut++;
 690:	87 e0       	ldi	r24, 0x07	; 7
 692:	80 93 42 01 	sts	0x0142, r24
	}

	/********** STOP BIT **********/
	if(Receiv_Statut==7)
 696:	90 91 42 01 	lds	r25, 0x0142
 69a:	97 30       	cpi	r25, 0x07	; 7
 69c:	71 f4       	brne	.+28     	; 0x6ba <Received_600_baud+0x12a>
	{
		if(Compteur_Timer==COMSPEEED) 
 69e:	80 91 2a 01 	lds	r24, 0x012A
 6a2:	88 30       	cpi	r24, 0x08	; 8
 6a4:	41 f4       	brne	.+16     	; 0x6b6 <Received_600_baud+0x126>
		{
			Compteur_Timer=0;
 6a6:	10 92 2a 01 	sts	0x012A, r1
			Receiv_Statut++;
 6aa:	80 93 42 01 	sts	0x0142, r24
			if(((PINC)&(1<<PINC0))==0)
 6ae:	30 9b       	sbis	0x06, 0	; 6
 6b0:	13 c0       	rjmp	.+38     	; 0x6d8 <Received_600_baud+0x148>
			{
	 			TIMER0_STOP();
				Receiving=OFF;
				return; 
			}
			else asm("nop");
 6b2:	00 00       	nop
 6b4:	1a c0       	rjmp	.+52     	; 0x6ea <Received_600_baud+0x15a>
		}
		else asm("nop");
 6b6:	00 00       	nop
 6b8:	18 c0       	rjmp	.+48     	; 0x6ea <Received_600_baud+0x15a>
	}
	else if(Receiv_Statut==8 || Receiv_Statut==9)
 6ba:	89 2f       	mov	r24, r25
 6bc:	88 50       	subi	r24, 0x08	; 8
 6be:	82 30       	cpi	r24, 0x02	; 2
 6c0:	98 f4       	brcc	.+38     	; 0x6e8 <Received_600_baud+0x158>
	{
		if(Compteur_Timer==COMSPEED) 
 6c2:	80 91 2a 01 	lds	r24, 0x012A
 6c6:	84 30       	cpi	r24, 0x04	; 4
 6c8:	69 f4       	brne	.+26     	; 0x6e4 <Received_600_baud+0x154>
		{
			Compteur_Timer=0;
 6ca:	10 92 2a 01 	sts	0x012A, r1
			Receiv_Statut++;
 6ce:	9f 5f       	subi	r25, 0xFF	; 255
 6d0:	90 93 42 01 	sts	0x0142, r25
			if(((PINC)&(1<<PINC0))==0)
 6d4:	30 99       	sbic	0x06, 0	; 6
 6d6:	04 c0       	rjmp	.+8      	; 0x6e0 <Received_600_baud+0x150>
			{
	 			TIMER0_STOP();
 6d8:	7b d0       	rcall	.+246    	; 0x7d0 <TIMER0_STOP>
				Receiving=OFF;
 6da:	10 92 26 01 	sts	0x0126, r1
 6de:	08 95       	ret
				return;
			}
			else asm("nop");
 6e0:	00 00       	nop
 6e2:	03 c0       	rjmp	.+6      	; 0x6ea <Received_600_baud+0x15a>
		}
		else asm("nop");
 6e4:	00 00       	nop
 6e6:	01 c0       	rjmp	.+2      	; 0x6ea <Received_600_baud+0x15a>
	}
	else asm("nop");
 6e8:	00 00       	nop

	/********** MISE EN FORME, ARRET DU TIMER ET RETOUR **********/
	if(Receiv_Statut==10)
 6ea:	80 91 42 01 	lds	r24, 0x0142
 6ee:	8a 30       	cpi	r24, 0x0A	; 10
 6f0:	09 f0       	breq	.+2      	; 0x6f4 <Received_600_baud+0x164>
 6f2:	59 c0       	rjmp	.+178    	; 0x7a6 <Received_600_baud+0x216>
	{
		TIMER0_STOP();
 6f4:	6d d0       	rcall	.+218    	; 0x7d0 <TIMER0_STOP>
		Data_Result=0;
 6f6:	10 92 41 01 	sts	0x0141, r1
		if(Data_com[7]==1) Data_Result=Data_Result+128;
 6fa:	80 91 22 01 	lds	r24, 0x0122
 6fe:	81 30       	cpi	r24, 0x01	; 1
 700:	19 f4       	brne	.+6      	; 0x708 <Received_600_baud+0x178>
 702:	80 e8       	ldi	r24, 0x80	; 128
 704:	80 93 41 01 	sts	0x0141, r24
		if(Data_com[6]==1) Data_Result=Data_Result+64;
 708:	80 91 21 01 	lds	r24, 0x0121
 70c:	81 30       	cpi	r24, 0x01	; 1
 70e:	29 f4       	brne	.+10     	; 0x71a <Received_600_baud+0x18a>
 710:	80 91 41 01 	lds	r24, 0x0141
 714:	80 5c       	subi	r24, 0xC0	; 192
 716:	80 93 41 01 	sts	0x0141, r24
		if(Data_com[5]==1) Data_Result=Data_Result+32;
 71a:	80 91 20 01 	lds	r24, 0x0120
 71e:	81 30       	cpi	r24, 0x01	; 1
 720:	29 f4       	brne	.+10     	; 0x72c <Received_600_baud+0x19c>
 722:	80 91 41 01 	lds	r24, 0x0141
 726:	80 5e       	subi	r24, 0xE0	; 224
 728:	80 93 41 01 	sts	0x0141, r24
		if(Data_com[4]==1) Data_Result=Data_Result+16;
 72c:	80 91 1f 01 	lds	r24, 0x011F
 730:	81 30       	cpi	r24, 0x01	; 1
 732:	29 f4       	brne	.+10     	; 0x73e <Received_600_baud+0x1ae>
 734:	80 91 41 01 	lds	r24, 0x0141
 738:	80 5f       	subi	r24, 0xF0	; 240
 73a:	80 93 41 01 	sts	0x0141, r24
		if(Data_com[3]==1) Data_Result=Data_Result+8;
 73e:	80 91 1e 01 	lds	r24, 0x011E
 742:	81 30       	cpi	r24, 0x01	; 1
 744:	29 f4       	brne	.+10     	; 0x750 <Received_600_baud+0x1c0>
 746:	80 91 41 01 	lds	r24, 0x0141
 74a:	88 5f       	subi	r24, 0xF8	; 248
 74c:	80 93 41 01 	sts	0x0141, r24
		if(Data_com[2]==1) Data_Result=Data_Result+4;
 750:	80 91 1d 01 	lds	r24, 0x011D
 754:	81 30       	cpi	r24, 0x01	; 1
 756:	29 f4       	brne	.+10     	; 0x762 <Received_600_baud+0x1d2>
 758:	80 91 41 01 	lds	r24, 0x0141
 75c:	8c 5f       	subi	r24, 0xFC	; 252
 75e:	80 93 41 01 	sts	0x0141, r24
		if(Data_com[1]==1) Data_Result=Data_Result+2;
 762:	80 91 1c 01 	lds	r24, 0x011C
 766:	81 30       	cpi	r24, 0x01	; 1
 768:	29 f4       	brne	.+10     	; 0x774 <Received_600_baud+0x1e4>
 76a:	80 91 41 01 	lds	r24, 0x0141
 76e:	8e 5f       	subi	r24, 0xFE	; 254
 770:	80 93 41 01 	sts	0x0141, r24
		if(Data_com[0]==1) Data_Result=Data_Result+1;
 774:	80 91 1b 01 	lds	r24, 0x011B
 778:	81 30       	cpi	r24, 0x01	; 1
 77a:	29 f4       	brne	.+10     	; 0x786 <Received_600_baud+0x1f6>
 77c:	80 91 41 01 	lds	r24, 0x0141
 780:	8f 5f       	subi	r24, 0xFF	; 255
 782:	80 93 41 01 	sts	0x0141, r24
		Receiving=OFF;
 786:	10 92 26 01 	sts	0x0126, r1
		Data_Received[Compteur_Data_Received]=Data_Result;
 78a:	80 91 29 01 	lds	r24, 0x0129
 78e:	e8 2f       	mov	r30, r24
 790:	f0 e0       	ldi	r31, 0x00	; 0
 792:	e5 5f       	subi	r30, 0xF5	; 245
 794:	fe 4f       	sbci	r31, 0xFE	; 254
 796:	90 91 41 01 	lds	r25, 0x0141
 79a:	90 83       	st	Z, r25
		Compteur_Data_Received++;
 79c:	8f 5f       	subi	r24, 0xFF	; 255
 79e:	80 93 29 01 	sts	0x0129, r24
		Receiv_Statut=0;
 7a2:	10 92 42 01 	sts	0x0142, r1
 7a6:	08 95       	ret

000007a8 <init_pcint>:

/* Initialisation PCINT */
void init_pcint(void)
{
	// Active les interruptions externe pcint1 donc sur PCINT0..23
	PCICR |= (1<<PCIE1);
 7a8:	e8 e6       	ldi	r30, 0x68	; 104
 7aa:	f0 e0       	ldi	r31, 0x00	; 0
 7ac:	80 81       	ld	r24, Z
 7ae:	82 60       	ori	r24, 0x02	; 2
 7b0:	80 83       	st	Z, r24
	// Active les interruptiosn sur PINC0 => PCINT8 ; PINC1 => PCINT9
	PCMSK1 |= (1<<PCINT8);//|(1<<PCINT9);
 7b2:	ec e6       	ldi	r30, 0x6C	; 108
 7b4:	f0 e0       	ldi	r31, 0x00	; 0
 7b6:	80 81       	ld	r24, Z
 7b8:	81 60       	ori	r24, 0x01	; 1
 7ba:	80 83       	st	Z, r24
}
 7bc:	08 95       	ret

000007be <INT_BP>:
void INT_BP(void)           //initialise le périphérique de int0 -> voir datasheet
{

     //EICRA = 0b00001010;     //0000: -/10: front descendant sur INT1/10: front descendant sur INT0
	 //EIMSK = 0b00000011;     //000000: -/11: interruptions sur INT0 et INT1
	sbiBF (PCICR, PCIE2);
 7be:	e8 e6       	ldi	r30, 0x68	; 104
 7c0:	f0 e0       	ldi	r31, 0x00	; 0
 7c2:	80 81       	ld	r24, Z
 7c4:	84 60       	ori	r24, 0x04	; 4
 7c6:	80 83       	st	Z, r24
	PCMSK2 = 0b01111000;
 7c8:	88 e7       	ldi	r24, 0x78	; 120
 7ca:	80 93 6d 00 	sts	0x006D, r24
}
 7ce:	08 95       	ret

000007d0 <TIMER0_STOP>:
// FUNCTIONS

// Arrete le timer et remet le compteur à 0
void TIMER0_STOP(void)
{
	TCCR0B = 0x00;
 7d0:	15 bc       	out	0x25, r1	; 37
	TCNT0 = 0x00;
 7d2:	16 bc       	out	0x26, r1	; 38
}
 7d4:	08 95       	ret

000007d6 <TIMER0_START>:

// Met le compteur à 0 et lance le timer
void TIMER0_START(void)
{
	TCNT0 = 0x00;
 7d6:	16 bc       	out	0x26, r1	; 38
	TCCR0B = (0<<CS02)|(1<<CS01)|(0<<CS00); // prescale de 8. => interruption toutes les 105*8*0.125=105µs
 7d8:	82 e0       	ldi	r24, 0x02	; 2
 7da:	85 bd       	out	0x25, r24	; 37
}
 7dc:	08 95       	ret

000007de <TIMER0_INIT>:

// Initialise le timer
void TIMER0_INIT(void)
{
	// mode CTC
	TCCR0A = (1<<WGM01)|(0<<WGM00);
 7de:	82 e0       	ldi	r24, 0x02	; 2
 7e0:	84 bd       	out	0x24, r24	; 36
	//TCCR0B = (0<<WGM02);
	// Activer les interruptions
	TIMSK0 = (1<<OCIE0A);
 7e2:	80 93 6e 00 	sts	0x006E, r24
	// Déclencher interruption à la valeur indiquée.
	OCR0A = 104; // 105-1
 7e6:	88 e6       	ldi	r24, 0x68	; 104
 7e8:	87 bd       	out	0x27, r24	; 39
}
 7ea:	08 95       	ret

000007ec <TIMER1_INIT>:

void TIMER1_INIT(void)   //initialise le périphérique du timer1 -> voir datasheet
{


    TCNT1  = 0b00000000;     //début compteur (commence à 0)
 7ec:	10 92 85 00 	sts	0x0085, r1
 7f0:	10 92 84 00 	sts	0x0084, r1
    TCCR1A = 0b01000000;     //00 pour dire rien sur OC1A/00: rien sur OCB/00: -/00: wgm11-10-> mode CTC     
 7f4:	80 e4       	ldi	r24, 0x40	; 64
 7f6:	80 93 80 00 	sts	0x0080, r24
    TCCR1B = 0b00001001;     //00:pas utilisé/0: -/01: wgm13-12 ->mode CTC/001: préscalaire de 1
 7fa:	89 e0       	ldi	r24, 0x09	; 9
 7fc:	80 93 81 00 	sts	0x0081, r24

	//mode CTC avec toggle de OC1A (se réalise automatiquement)
	   
    TIMSK1 = 0b00000000;     //00: -/0: pas la capture/00: -/010: interruption sur OCR1A   
 800:	10 92 6f 00 	sts	0x006F, r1
    OCR1A  = 249 ;           //on commence à 40kHz -> OCR1A (voir formule) = 249          
 804:	89 ef       	ldi	r24, 0xF9	; 249
 806:	90 e0       	ldi	r25, 0x00	; 0
 808:	90 93 89 00 	sts	0x0089, r25
 80c:	80 93 88 00 	sts	0x0088, r24

}
 810:	08 95       	ret

00000812 <TIMER2_INIT>:

// Init timer2
void TIMER2_INIT(void)
{
		// mode CTC
	TCCR2A = (1<<WGM21)|(0<<WGM20);
 812:	82 e0       	ldi	r24, 0x02	; 2
 814:	80 93 b0 00 	sts	0x00B0, r24
	// Activer les interruptions
	TIMSK2 = (1<<OCIE2A);
 818:	80 93 70 00 	sts	0x0070, r24
	// Déclencher interruption à la valeur indiquée.
	OCR2A = 104; // 105-1
 81c:	88 e6       	ldi	r24, 0x68	; 104
 81e:	80 93 b3 00 	sts	0x00B3, r24
}
 822:	08 95       	ret

00000824 <TIMER2_STOP>:

// Arrete le timer et remet le compteur à 0
void TIMER2_STOP(void)
{
	TCCR2B = 0x00;
 824:	10 92 b1 00 	sts	0x00B1, r1
	TCNT2 = 0x00;
 828:	10 92 b2 00 	sts	0x00B2, r1
}
 82c:	08 95       	ret

0000082e <TIMER2_START>:

// Met le compteur à 0 et lance le timer
void TIMER2_START(void)
{
	TCNT2 = 0x00;
 82e:	10 92 b2 00 	sts	0x00B2, r1
	TCCR2B = (0<<CS02)|(1<<CS01)|(0<<CS00); // prescale de 8. => interruption toutes les 105*8*0.125=105µs
 832:	82 e0       	ldi	r24, 0x02	; 2
 834:	80 93 b1 00 	sts	0x00B1, r24
}
 838:	08 95       	ret

0000083a <ConvertAsciiToValue>:

/* Fonction qui donne la valeur d'un caractère ASCII*/
unsigned char ConvertAsciiToValue(unsigned char ascii)
{
	unsigned char value;
	switch(ascii)
 83a:	90 e0       	ldi	r25, 0x00	; 0
 83c:	fc 01       	movw	r30, r24
 83e:	f0 97       	sbiw	r30, 0x30	; 48
 840:	e7 31       	cpi	r30, 0x17	; 23
 842:	f1 05       	cpc	r31, r1
 844:	f8 f4       	brcc	.+62     	; 0x884 <ConvertAsciiToValue+0x4a>
 846:	e6 5e       	subi	r30, 0xE6	; 230
 848:	ff 4f       	sbci	r31, 0xFF	; 255
 84a:	09 94       	ijmp
 84c:	81 e0       	ldi	r24, 0x01	; 1
 84e:	08 95       	ret
 850:	80 e0       	ldi	r24, 0x00	; 0
 852:	08 95       	ret
 854:	82 e0       	ldi	r24, 0x02	; 2
 856:	08 95       	ret
		case '1' :
			value = 1;
			break;
		case '2' :
			value = 2;
			break;
 858:	83 e0       	ldi	r24, 0x03	; 3
 85a:	08 95       	ret
		case '3' :
			value = 3;	
			break;
 85c:	84 e0       	ldi	r24, 0x04	; 4
 85e:	08 95       	ret
		case '4' :
			value = 4;
			break;
 860:	85 e0       	ldi	r24, 0x05	; 5
 862:	08 95       	ret
		case '5' :
			value = 5;
			break;
 864:	86 e0       	ldi	r24, 0x06	; 6
 866:	08 95       	ret
		case '6' :
			value = 6;
			break;
 868:	89 e0       	ldi	r24, 0x09	; 9
 86a:	08 95       	ret
		case '8' :
			value = 7;
			break;
		case '9' :
			value = 9;
			break;
 86c:	8a e0       	ldi	r24, 0x0A	; 10
 86e:	08 95       	ret
		case 'A' :
			value = 10;
			break;
 870:	8b e0       	ldi	r24, 0x0B	; 11
 872:	08 95       	ret
		case 'B' :
			value = 11;
			break;
 874:	8c e0       	ldi	r24, 0x0C	; 12
 876:	08 95       	ret
		case 'C' :
			value = 12;
			break;
 878:	8d e0       	ldi	r24, 0x0D	; 13
 87a:	08 95       	ret
		case 'D' :
			value = 13;
			break;
 87c:	8e e0       	ldi	r24, 0x0E	; 14
 87e:	08 95       	ret
		case 'E' :
			value = 14;
			break;
 880:	8f e0       	ldi	r24, 0x0F	; 15
 882:	08 95       	ret
		case 'F' :
			value = 15;
			break;
 884:	8f ef       	ldi	r24, 0xFF	; 255
 886:	08 95       	ret
 888:	87 e0       	ldi	r24, 0x07	; 7
		default :
			value = 0xFF;
	}
	return value;
}
 88a:	08 95       	ret

0000088c <ConvertValueToAscii>:

/* Fonction qui donne le caractère ASCII d'une valeur */
unsigned char ConvertValueToAscii(unsigned char value)
{
	unsigned char ascii;
	switch(value)
 88c:	e8 2f       	mov	r30, r24
 88e:	f0 e0       	ldi	r31, 0x00	; 0
 890:	e0 31       	cpi	r30, 0x10	; 16
 892:	f1 05       	cpc	r31, r1
 894:	18 f5       	brcc	.+70     	; 0x8dc <ConvertValueToAscii+0x50>
 896:	ef 5c       	subi	r30, 0xCF	; 207
 898:	ff 4f       	sbci	r31, 0xFF	; 255
 89a:	09 94       	ijmp
 89c:	81 e3       	ldi	r24, 0x31	; 49
 89e:	08 95       	ret
 8a0:	80 e3       	ldi	r24, 0x30	; 48
 8a2:	08 95       	ret
 8a4:	82 e3       	ldi	r24, 0x32	; 50
 8a6:	08 95       	ret
		case 1 :
			ascii = '1';
			break;
		case 2 :
			ascii = '2';
			break;
 8a8:	83 e3       	ldi	r24, 0x33	; 51
 8aa:	08 95       	ret
		case 3 :
			ascii = '3';	
			break;
 8ac:	84 e3       	ldi	r24, 0x34	; 52
 8ae:	08 95       	ret
		case 4 :
			ascii = '4';
			break;
 8b0:	85 e3       	ldi	r24, 0x35	; 53
 8b2:	08 95       	ret
		case 5 :
			ascii = '5';
			break;
 8b4:	86 e3       	ldi	r24, 0x36	; 54
 8b6:	08 95       	ret
		case 6 :
			ascii = '6';
			break;
 8b8:	87 e3       	ldi	r24, 0x37	; 55
 8ba:	08 95       	ret
		case 7 :
			ascii = '7';
			break;
 8bc:	88 e3       	ldi	r24, 0x38	; 56
 8be:	08 95       	ret
		case 8 :
			ascii = '8';
			break;
 8c0:	89 e3       	ldi	r24, 0x39	; 57
 8c2:	08 95       	ret
		case 9 :
			ascii = '9';
			break;
 8c4:	81 e4       	ldi	r24, 0x41	; 65
 8c6:	08 95       	ret
		case 10 :
			ascii = 'A';
			break;
 8c8:	82 e4       	ldi	r24, 0x42	; 66
 8ca:	08 95       	ret
		case 11 :
			ascii = 'B';
			break;
 8cc:	83 e4       	ldi	r24, 0x43	; 67
 8ce:	08 95       	ret
		case 12 :
			ascii = 'C';
			break;
 8d0:	84 e4       	ldi	r24, 0x44	; 68
 8d2:	08 95       	ret
		case 13 :
			ascii = 'D';
			break;
 8d4:	85 e4       	ldi	r24, 0x45	; 69
 8d6:	08 95       	ret
		case 14 :
			ascii = 'E';
			break;
 8d8:	86 e4       	ldi	r24, 0x46	; 70
 8da:	08 95       	ret
		case 15 :
			ascii = 'F';
			break;
 8dc:	8f ef       	ldi	r24, 0xFF	; 255
		default :
			ascii = 0xFF;
	}
	return ascii;
}
 8de:	08 95       	ret

000008e0 <_exit>:
 8e0:	f8 94       	cli

000008e2 <__stop_program>:
 8e2:	ff cf       	rjmp	.-2      	; 0x8e2 <__stop_program>
